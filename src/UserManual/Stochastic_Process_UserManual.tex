% Copyright (C) 2005-2015 Airbus - EDF - IMACS - Phimeca
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts.  A copy of the license is included in the section entitled "GNU
% Free Documentation License".
\newpage
\extanchor{stochasticprocess}
\section{Stochastic process}


% ===================================================================
\subsection{General objects}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\index{Process}
\subsubsection{Process}

A multivariate stochastic process $X$ of dimension $d$ is defined by:
\begin{align}\label{processDef}
X: \Omega \times\cD \rightarrow \Rset^d
\end{align}
where $\omega \in \Omega$ is an event, $\cD$ is a domain of $\Rset^n$, $\vect{t}\in \cD$ is a multivariate index and $X(\omega, \vect{t}) \in \Rset^d$.\\

A realization of the process $X$, for a given $\omega \in \Omega$ is $X(\omega): \cD  \rightarrow \Rset^d$ defined by:
\begin{align}\label{continuousReal}
X(\omega)(\vect{t})=X(\omega, \vect{t})
\end{align}

$X_{\vect{t}}: \Omega \rightarrow \Rset^d$ is the random variable at index $\vect{t} \in \cD$ defined by:

\begin{align}\label{RandomVarVertex}
X_{\vect{t}}(\omega)=X(\omega, \vect{t})
\end{align}


\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{Process(process)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{process}: a ProcessImplementation (which is a particular Process)
\end{description}
\bigskip

\item[Value:] a Process
\rule{0pt}{1em}
\begin{description}
\item This class enables to model a stochastic process.
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getContinuousRealization}
\begin{description}
\item[Usage:] \textit{getContinuousRealization()}
\item[Arguments:] none
\item[Value:] a NumericalMathFunction defined in (\ref{continuousReal})).\\
According to the process, the continuous realizations are build :
\begin{itemize}
\item either using a dedicated functional model if it exists: e.g. a functional basis process (see Figures \ref{continuousReal1} to \ref{FBP});
\item or using an interpolation from a discrete realization of the process on $\cM$: in  dimension $d=1$,  a linear interpolation and in dimension $d \geq 2$,  a piecewise constant function (the value at a given position is equal to the value at the nearest vertex of the mesh of the process).
\end{itemize}
\end{description}
\bigskip

\item \textit{getDescription}
\begin{description}
\item[Usage:] \textit{getDescription()}
\item[Arguments:] none
\item[Value:] a string, the description of the process
\end{description}
\bigskip

\item \textit{getDimension}
\begin{description}
\item[Usage:] \textit{getDimension()}
\item[Arguments:] none
\item[Value:] an integer, the dimension of the stochastic process
\end{description}
\bigskip

\item \textit{getMarginalProcess}
\begin{description}
\item[Usage:] \textit{getMarginalProcess(k)}
\item[Arguments:] $k$, an integer
\item[Value:] a Process, the $k-th$ marginal of the random process.
\end{description}
\bigskip

\item \textit{getMesh}
\begin{description}
\item[Usage:] \textit{getMesh()}
\item[Arguments:] none
\item[Value:] a Mesh over which the domaine $\cD$ is discretized
\end{description}
\bigskip

\item \textit{getSpatialDimension}
\begin{description}
\item[Usage:] \textit{getMesh()}
\item[Arguments:] none
\item[Value:] an integer, the dimension $n$
\end{description}
\bigskip


\item \textit{getRealization}
\begin{description}
\item[Usage:] \textit{getRealization()}
\item[Arguments:] none
\item[Value:] a Field that contains a mesh over which the process is discretized and the values of the process at the vertices of the mesh.
\end{description}
\bigskip

\item \textit{getSample}
\begin{description}
\item[Usage:] \textit{getSample(n)}
\item[Arguments:] $n$, an integer
\item[Value:] a ProcessSample , $n$ realizations of the random process.
\end{description}
\bigskip

\item \textit{getTimeGrid}
\begin{description}
\item[Usage:] \textit{getTimeGrid()}
\item[Arguments:] none
\item[Value:] a RegularGrid, when the mesh associated to the process can be interpreted as a RegularGrid: we check if the vertices of the mesh are scalar and are regularly spaced in $\Rset$ but we don't check if the connectivity of the mesh is conform to the one of a regular grid (whithout any hole and composed of ordered instants).
\end{description}
\bigskip

\item \textit{isComposite}
\begin{description}
\item[Usage:] \textit{isComposite()}
\item[Arguments:] none
\item[Value:] a Bool that checks  if the process is composite (built upon a function and a process).
\end{description}
\bigskip

\item \textit{isStationary}
\begin{description}
\item[Usage:] \textit{isStationary()}
\item[Arguments:] none
\item[Value:]a Bool that checks if the process is stationary.
\end{description}
\bigskip

\item \textit{isNormal}
\begin{description}
\item[Usage:] \textit{isNormal()}
\item[Arguments:] none
\item[Value:] a Bool that checks if the process is Normal.
\end{description}
\bigskip

\item \textit{isStationary}
\begin{description}
\item[Usage:] \textit{isStationary()}
\item[Arguments:] none
\item[Value:] a Bool that checks if the process is stationary
\end{description}
\bigskip

\item \textit{setTimeGrid}
\begin{description}
\item[Usage:] \textit{setTimeGrid(timeGrid)}
\item[Arguments:] \textit{timeGrid}, a RegularGrid
\item[Value:] Fix the time grid of observation of the process.
\end{description}

\end{description}

\end{description}






% ===================================================
\newpage
\index{Field}
\subsubsection{Field}



\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{Field(mesh, dim)}
\item \textit{Field(mesh, values)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{mesh}: a Mesh where each vertice is in $\Rset^n$
\item \textit{dim}: an integer, the dimension $d$ in (\ref{processDef}).
\item \textit{values}: a NumericalSample of dimension $d$: the  values associated to the vertices of the mesh. The size of \textit{values} is equal to the number of vertices in the associated mesh. So we must have the equality between \textit{values.getSize()} and \textit{mesh.getVerticesNumber()}.
\end{description}
\bigskip

\item[Value:] a Field
\rule{0pt}{1em}
\begin{description}
\item A Field   contains a mesh and the values associated to each vertice of the mesh.\\
In the context of a stochastic process, it contains the mesh defined in (\ref{processDef}) and a realization $X(\omega)$ (the random values of the vertices of the mesh).
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{drawMarginal}
\begin{description}
\item[Usage:] \textit{drawMarginal(index, interpolate)}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{index}: an integer, the selected marginal.
\item \textit{interpolate}: a Bool that indicates if the values at each vertex are linearly interpolated.
\end{description}
\item[Value:] For now, if the dimension of the mesh is $n=1$, it draws the graph of the piecewise linear function based on the selected marginal values of the field and the vertices coordinates (in $\Rset$) if \textit{interpolate=True}; otherwise, it draws the cloud of points which coordinates are (vertex, value of the marginal \textit{index}).\\
If the dimension of the mesh is 2, it draws several iso-values curves of the selected marginal, based on a piecewise linear interpolation within the simplices (triangles) of the mesh, if \textit{interpolate=True}; otherwise, it draws the cloud which is the set of the vertices colored according to the values of the field at each vertex.
\end{description}
\bigskip

\item \textit{exportToVTKFile}
\begin{description}
\item[Usage:] \textit{exportToVTKFile(myVTKFile.vtk)}
\item[Arguments:] \textit{myVTKFile}: a String, the name of the output file without the extension.
\item[Value:] It creates the file \textit{myVTKFile.vtk} that contains the mesh and the associated random values that can be visualised with  the open source software ParaView (www.paraview.org).
\end{description}
\bigskip

\item \textit{getDimension}
\begin{description}
\item[Usage:] \textit{getDimension()}
\item[Arguments:] none
\item[Value:] an integer, the dimension $d$ of the values (see \ref{processDef})
\end{description}
\bigskip

\item \textit{getMesh}
\begin{description}
\item[Usage:] \textit{getMesh()}
\item[Arguments:] none
\item[Value:] a Mesh, the mesh over which the process if discretized.
\end{description}
\bigskip


\item \textit{getSpatialDimension}
\begin{description}
\item[Usage:] \textit{getSpatialDimension()}
\item[Arguments:] none
\item[Value:] an integer, the dimension $n$ of the vertices of the mesh (see \ref{processDef})
\end{description}
\bigskip

\item \textit{getSample}
\begin{description}
\item[Usage:] \textit{getSample()}
\item[Arguments:] none
\item[Value:] a NumericalSample, which regroups all the values associated to the mesh. The size of the sample is the number of vertices of the mesh and the dimension is the dimension of the values ($d$).
\end{description}
\bigskip

\item \textit{getSize}
\begin{description}
\item[Usage:] \textit{getSize()}
\item[Arguments:] none
\item[Value:] an integer, the number of vertices of the mesh.
\end{description}
\bigskip

\item \textit{getSpatialMean}
\begin{description}
\item[Usage:] \textit{getSpatialMean()}
\item[Arguments:] none
\item[Value:] a NumericalPoint, the mean of all the values stored in \textit{values}. If we note $(\vect{t}_0, \dots, \vect{t}_{N-1})$ the vertices of the mesh  and $(\vect{x}_0, \dots, \vect{x}_{N-1})$ the associated values in $\Rset^d$, then the spatial mean of the field is  defined by:
\begin{align}\label{Field.getSpatialMean}
\displaystyle \frac{1}{N} \sum_{i=0}^{N-1} \vect{x}_i
\end{align}
% For version after 1.3:
% \begin{align}\label{spatMeanField}
%   \displaystyle \frac{1}{V} \sum_{S_i \in \cM} \left( \frac{1}{d+1}\sum_{k=0}^{d} \vect{x}_{i_k}\right) |S_i|
% \end{align}
% where $S_i$ is the simplex of index $i$ of $\cM$, $|S_i|$ its volume and $(\vect{x}_{i_0}, \dots, \vect{x}_{i_d})$ the values of the field associated to the  vertices pf $\cS_i$, and $\displaystyle V=\sum_{S_i \in \cD} |S_i|$.\\
% (\ref{spatMeanField}) is an estimation of the spatial mean of the process $X$ defined in (\ref{spatMean}).
\end{description}
\bigskip

\item \textit{getTemporalMean}
\begin{description}
\item[Usage:] \textit{getTemporalMean()}
\item[Arguments:] none
\item[Value:] a NumericalPoint, the mean of all the values stored in \textit{values}. This method makes the same calculus than the method {\itshape getSpatialMean} but it can be called only when the mesh can be interpreted as a RegularGrid.
\end{description}
\bigskip

\item \textit{getTimeGrid}
\begin{description}
\item[Usage:] \textit{getTimeGrid()}
\item[Arguments:]none
\item[Value:]  a RegularGrid, when the mesh associated to the process can be interpreted as a RegularGrid: we check if the vertices of the mesh are scalar and are regularly spaced in $\Rset$ but we don't check if the connectivity of the mesh is conform to the one of a regular grid (whithout any hole and composed of ordered instants).
\end{description}
\bigskip

\item \textit{getValueAtIndex}
\begin{description}
\item[Usage:] \textit{getValueAtIndex(index)}
\item[Arguments:] \textit{index}: an integer which characterizes one vertex of the mesh.
\item[Value:] a NumericalPoint of dimension $d$ (see (\ref{processDef})): the \textit{index}+1 component of the NumericalSample stored in the Field: \textit{values[index]}.
\end{description}
\bigskip

\item \textit{getValueAtNearestPosition}
\begin{description}
\item[Usage:] \textit{getValueAtNearestPosition(position)}
\item[Arguments:] \textit{position}: a NumericalPoint of dimension $n$.
\item[Value:] a NumericalPoint of dimension $d$, the random value of the vertex the nearest of \textit{position} in Euclidean norm.
\end{description}
\bigskip

\item \textit{getValues}
\begin{description}
\item[Usage:] \textit{getValues()}
\item[Arguments:] none
\item[Value:] a NumericalSample, the random values associated to the vertices of the mesh.
\end{description}

\end{description}

\end{description}



% ===================================================================
\newpage

\index{TimeSeries}
\subsubsection{TimeSeries}

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{TimeSeries()}
\item \textit{TimeSeries(timeGrid, sample)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{timeGrid}  :        a RegularGrid, the time stamps on which the realizations are observed
\item \textit{sample}    :        a NumericalSample, the data values in $\Rset^d$
\end{description}

\item[Value:] TimeSeries
\begin{description}
\item the time series is filled with the time stamps  \textit{timeGrid} and the values \textit{sample}
\end{description}

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}


\item \textit{exportToVTKFile}
\begin{description}
\item[Usage:] \textit{exportToVTKFile(fileName.vtk)}
\item[Arguments:] \textit{fileName.vtk}: the name of the file in the format VTK, with the extension \emph{.vtk}.
\item[Value:] a VTK file
\end{description}
\bigskip



\item \textit{getDimension}
\begin{description}
\item[Usage:] \textit{getDimension()}
\item[Arguments:] none
\item[Value:] an integer : the dimension of the values associated to the time stamps of the regular grid ($d$)
\end{description}
\bigskip

\item \textit{getTemporalMean}
\begin{description}
\item[Usage:] \textit{getTemporalMean()}
\item[Arguments:] none
\item[Value:] a NumericalPoint : compute the temporal mean which corresponds to the mean of its values.
\end{description}
\bigskip

\item \textit{getTimeGrid}
\begin{description}
\item[Usage:] \textit{getTimeGrid()}
\item[Arguments:] none
\item[Value:] a RegularGrid : the time stamps of observation
\end{description}
\bigskip

\item \textit{getValueAtIndex}
\begin{description}
\item[Usage:] \textit{getValueAtIndex(k)}
\item[Arguments:] an integer
\item[Value:] a NumericalPoint : the $k-th$ value of the TimeSeries
\end{description}
\bigskip

\item \textit{getValueAtNearestTime}
\begin{description}
\item[Usage:] \textit{getValueAtNearestTime(t)}
\item[Arguments:] a NumericalScalar
\item[Value:] a NumericalPoint : the value of the TimeSeries observed at time $t$
\end{description}
\bigskip

\item \textit{getSize}
\begin{description}
\item[Usage:] \textit{getSize()}
\item[Arguments:] none
\item[Value:] an integer, the number of time stamps of the regular grid
\end{description}
\bigskip

\item \textit{getSample}
\begin{description}
\item[Usage:] \textit{getSample()}
\item[Arguments:] none
\item[Value:] a NumericalSample : the data of the TimeSeries
\end{description}
\bigskip

\item \textit{getName}
\begin{description}
\item[Usage:] \textit{getName()}
\item[Arguments:] none
\item[Value:] a string, the name of the TimeSeries
\end{description}
\bigskip

\item \textit{setValueAtIndex}
\begin{description}
\item[Usage:] \textit{setValueAtIndex(i, np)}
\item[Arguments:] an integer, a NumericalPoint
\item[Value:] None; the value $np$ is set at the index $i$
\end{description}
\bigskip

\item \textit{setValueAtNearestTime}
\begin{description}
\item[Usage:] \textit{setValueAtNearestTime(t, np)}
\item[Arguments:] a NumericalScalar, a NumericalPoint
\item[Value:] None; the value $np$ is set at the index which corresponds to the nearest time $t$
\end{description}
\bigskip

\item \textit{setName}
\begin{description}
\item[Usage:] \textit{setName(name)}
\item[Arguments:] name : a string
\item[Value:] the TimeSeries is named \textit{name}
\end{description}
\bigskip



\end{description}

\end{description}


% ===================================================================

\newpage
% \index{Stochastic Process!General common objects!ProcessSample}
\index{ProcessSample}
\subsubsection{ProcessSample}

A ProcessSample stores a sample of fields. We note $K$ the number of fields contained in the process sample and $d$ the dimension of the values associated to the common mesh $\cM \in \Rset^n$.\\

A process sample can be obtained as $K$ realizations of a multivariate stochastic process  $X: \Omega \times \cD \rightarrow \Rset^d$   of dimension $d$ where $\cD \in \Rset^n$, when the realizations are discretized on the same mesh $\cM$ of $\cD$. The  values $(\vect{x}_0^k, \dots, \vect{x}_{N-1}^k)$ of the field $k$, associated to the vertices $(\vect{t}_0, \dots, \vect{t}_{N-1})$ of $\cM$, are defined by:
\begin{align}
\forall i \in [0, N-1],\quad   \vect{x}_i= X(\omega_k)(\vect{t}_i)
\end{align}

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{ProcessSample()}
\item \textit{ProcessSample(mesh, size, dimension)}
\item \textit{ProcessSample(size, field)}
\item \textit{ProcessSample(collection)}

\end{description}



\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{field}   :      a Field
\item \textit{size}       :      an integer, size of the ProcessSample
\item \textit{dimension}  :      an integer, dimension of the ProcessSample
\end{description}

\item[Value:] ProcessSample
\begin{description}
\item while using the second parameters set, the process sample is based on the mesh \textit{mesh} and its size (number of fields in the process sample) is set to \textit{size} and its dimension (dimension of the values associated to the mesh) if set to \textit{dimension}. The values are fixed by default to zero.
\item while using the third parameters set, the process sample is filled with \textit{size} copies of the field \textit{field}.
\end{description}

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}


\item \textit{add}
\begin{description}
\item[Usage:] \textit{add(field)}
\item[Arguments:] \textit{field}:  a Field
\item[Value:] Add to the process sample a new field which has to share the same mesh as the other fields already contained in the process sample.
\end{description}
\bigskip

\item \textit{computeMean}
\begin{description}
\item[Usage:] \textit{computeMean()}
\item[Arguments:] none
\item[Value:] a Field, built as follows. At each vertex of the mesh, we calculate the mean of  the values of all the fields contained in the process sample:
\begin{align}\label{meanProcessSample}
\displaystyle \frac{1}{K} \sum_{k=1}^K \vect{x}_i^k
\end{align}
The resulting field has a size equal to $N$ and a dimension equal to $d$. It shares the same mesh.


\end{description}
\bigskip

\item \textit{computeQuantilePerComponent}
\begin{description}
\item[Usage:] \textit{computeQuantilePerComponent(prob)}
\item[Arguments:] prob: a real value in $(0, 1)$.
\item[Value:] a TimeSeries with size and dimension parameters the same as the ProcessSample's ones. The values at a given time index are component-wise estimates of the quantiles of level prob of the underlying process at this time value, using the empirical quantile.
\end{description}
\bigskip

\item \textit{computeSpatialMean}
\begin{description}
\item[Usage:] \textit{computeSpatialMean()}
\item[Arguments:] none
\item[Value:] a NumericalSample of size $K$ and  dimension $d$, built as follows: for each field contained in the process sample, we evaluate the spatial mean defined in (\ref{Field.getSpatialMean})
\end{description}
\bigskip

\item \textit{computeTemporalMean}
\begin{description}
\item[Usage:] \textit{computeTemporalMean()}
\item[Arguments:] none
\item[Value:] a NumericalSample  of size $K$ and  dimension $d$, built as follows: for each field contained in the process sample, we evaluate its temporal mean. This method can be used only when the mesh can be interpreted as a regular grid.
\end{description}
\bigskip

\item \textit{drawMarginal}
\begin{description}
\item[Usage:] \textit{drawMarginal(i)}
\item[Arguments:] an integer
\item[Value:] a Graph that contains the collection of the drawing of the marginal of each field (with interpolation). It is restricted to mesh of dimension $n=1$ only.
\end{description}
\bigskip


\item \textit{getDimension}
\begin{description}
\item[Usage:] \textit{getDimension()}
\item[Arguments:] none
\item[Value:] an integer : the dimension of the fields contained on the process sample (which is $d$).
\end{description}
\bigskip

\item \textit{getSize}
\begin{description}
\item[Usage:] \textit{getSize()}
\item[Arguments:] none
\item[Value:] an integer : the number of fields contained on the process sample (which is $K$).
\end{description}
\bigskip

\item \textit{getMesh}
\begin{description}
\item[Usage:] \textit{getMesh()}
\item[Arguments:] none
\item[Value:] a Mesh, the mesh associated to all the fields of the process sample.
\end{description}

\end{description}

\end{description}



% ================================================================================================================


\newpage
% \index{Stochastic Process!Temporal information}
\subsection{Temporal information}


% \index{Stochastic Process!Temporal information!CovarianceModel}
\index{CovarianceModel}
\subsubsection{CovarianceModel}

This class is the interface of \textit{CovarianceModelImplementation}.

We consider $X: \Omega \times\cD \rightarrow \Rset^d$ a multivariate stochastic process of dimension $d$, where $\omega \in \Omega$ is an event, $\cD$ is a domain of $\Rset^n$, $\vect{t}\in \cD$ is a multivariate index and $X(\omega, \vect{t}) \in \Rset^d$.\\
We note $X_{\vect{t}}: \Omega \rightarrow \Rset^d$ the random variable at index $\vect{t} \in \cD$ defined by $X_{\vect{t}}(\omega)=X(\omega, \vect{t})$ and $X(\omega): \cD  \rightarrow \Rset^d$ a realization of the process $X$, for a given $\omega \in \Omega$ defined by $X(\omega)(\vect{t})=X(\omega, \vect{t})$.\\

If the process is a second order process, we note:
\begin{itemize}
\item  $m : \cD \rightarrow  \Rset^d$ its \emph{mean function},  defined  by $m(\vect{t})=\Expect{X_{\vect{t}}}$,
\item $C : \cD \times \cD \rightarrow  \cM_{d \times d}(\Rset)$ its    \emph{covariance function},  defined  by $C(\vect{s}, \vect{t})=\Expect{(X_{\vect{s}}-m(\vect{s}))(X_{\vect{t}}-m(\vect{t}))^t}$,
\item  $R : \cD \times \cD \rightarrow  \mathcal{M}_{d \times d}(\Rset)$ its \emph{ correlation function}, defined for all $(\vect{s}, \vect{t})$, by $R(\vect{s}, \vect{t})$ such that for all $(i,j)$, $R_{ij}(\vect{s}, \vect{t})=C_{ij}(\vect{s}, \vect{t})/\sqrt{C_{ii}(\vect{s}, \vect{t})C_{jj}(\vect{s}, \vect{t})}$.
\end{itemize}



\begin{description}

\item[Usage:] \textit{CovarianceModel(myCovarianceModelImplementation)}
\bigskip

\item[Arguments:] \textit{myCovarianceModelImplementation}: the implementation of a covariance model. For example, the Exponential model.

\bigskip

\item[Value:] a CovarianceModel
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{computeCovariance}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{computeCovariance(t, s)}
\item \textit{computeCovariance($\tau$)}
\end{description}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{t, s}: NumericalPoint or NumericalScalar
\item \textit{$\tau$}: NumericalPoint or NumericalScalar
\end{description}]
\item[Value:] a CovarianceMatrix $\in\cM_{d\times d}(\Rset)$ that evaluates the covariance model $C : \cD \times \cD \rightarrow  \cM_{d \times d}(\Rset)$ at  $(s,t)\in \Rset^n$:
\begin{align*}
C(\vect{s}, \vect{t})=\Expect{(X_{\vect{s}}-m(\vect{s}))(X_{\vect{t}}-m(\vect{t}))^t}
\end{align*}
In the second usage, the covariance model must be stationary. Then we note $C^{stat}(\vect{\tau})$ for $C(\vect{s}, \vect{s}+\vect{\tau})$ as this quantity does not depend on $\vect{s}$.\\
\end{description}
\bigskip

\item \textit{discretizeCovariance}
\begin{description}
\item[Usage:] \textit{discretizeCovariance(mesh)}
\item[Arguments:] \textit{mesh}:  a Mesh,  of size $N$
\item[Value:] a CovarianceMatrix $\in\cM_{nd\times nd}(\Rset)$ (if the process is of dimension $d$) makes a discretization of the model on  \textit{mesh} composed of the vertices $(\vect{t}_1, \dots, \vect{t}_{N-1})$ and returns the covariance matrix  :
\begin{equation}\label{covMatrix}
\mat{C}_{1,\dots,k} = \left(
\begin{array}{cccc}
C(\vect{t}_1, \vect{t}_1) &C(\vect{t}_1, \vect{t}_2) & \hdots & C(\vect{t}_1, \vect{t}_{k}) \\
\hdots & C(\vect{t}_2, \vect{t}_2)  & \hdots & C(\vect{t}_2, \vect{t}_{k}) \\
\hdots & \hdots & \hdots & \hdots \\
\hdots & \hdots & \hdots & C(\vect{t}_{k}, \vect{t}_{k})
\end{array}
\right)
\end{equation}

\end{description}
\bigskip

\item \textit{getDimension}
\begin{description}
\item[Usage:] \textit{getDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the dimension  $d$
\end{description}
\bigskip

\item \textit{isStationary}
\begin{description}
\item[Usage:] \textit{isStationary()}
\item[Arguments:] none
\item[Value:] a boolean, \textit{true} if the model is stationary
\end{description}
\bigskip

\end{description}

\end{description}


% =====================================================
\newpage
% \index{Stochastic Process!Temporal information!StationaryCovarianceModel}
\index{StationaryCovarianceModel}
\subsubsection{StationaryCovarianceModel}

This class inherits from CovarianceModel. This class is not used alone.\\

\begin{description}

\item[Usage:] \textit{StationaryCovarianceModel()}
\bigskip

\item[Arguments:]  none.
\bigskip

\item[Value:] a StationaryCovarianceModel. For example, the Exponential one.
\bigskip

\item[Description:]

The covariance function  $C$ is stationnary when it  is invariant by  translation:
\begin{eqnarray}\label{covStat}
\forall (\vect{s},\vect{t},\vect{h}) \in \cD,  &  \, C(\vect{s}, \vect{s}+\vect{h})  =C(\vect{t}, \vect{t}+\vect{h})
\end{eqnarray}
We note $C^{stat}(\vect{\tau})$ for  $C(\vect{s}, \vect{s}+\vect{\tau})$.

\end{description}



% ==================================================================================================
\newpage
% \index{Stochastic Process!Temporal information!ExponentialModel}
\index{ExponentialModel}
\subsubsection{ExponentialModel}

\label{expModel}

This class inherits from \textit{CovarianceModelImplementation} and \textit{StationaryCovarianceModel} class. \\
The Exponential model defines the covariance function  $C^{stat}(\vect{\tau})$ such that :
\begin{equation}
\label{fullMultivariateExponential2}
\forall \vect{\tau} \in \cD,\quad C^{stat}( \vect{\tau} )=\left[\mat{A}\mat{\Delta}( \vect{\tau} ) \right] \,\mat{R}\, \left[ \mat{\Delta}( \vect{\tau} )\mat{A}\right]
\end{equation}
where $\mat{R} \in  \mathcal{M}_{d \times d}([-1, 1])$ is a correlation matrix, $\mat{\Delta}( \vect{\tau} ) \in \mathcal{M}_{d \times d}(\Rset)$ is defined by:
\begin{equation}
\label{fullMultivariateExponential3}
\mat{\Delta}( \vect{\tau} )= \mbox{Diag}(e^{-\lambda_1|\tau|/2}, \dots, e^{-\lambda_d|\tau|/2})
\end{equation}
and $\mat{A}\in \mathcal{M}_{d \times d}(\Rset)$ is defined by:
\begin{equation}
\label{fullMultivariateExponential4}
\mat{A}= \mbox{Diag}(a_1, \dots, a_d)
\end{equation}
whith $\lambda_i>0$ and $a_i>0$ for any $i$.\\
We call $\vect{a}$ the amplitude vector and $\vect{\lambda}$ the scale vector.\\


We define the spatial covariance matrix $\mat{C}^{spat}$ by:
\begin{equation}\label{relRA}
\forall \vect{t} \in \cD,\quad \mat{C}^{spat} = \Expect{X_{\vect{t}}X^t_{\vect{t}}} = \mat{A}\,\mat{R}\, \mat{A}
\end{equation}



\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{ExponentialModel()}
\item \textit{ExponentialModel(amplitude, scale)}
\item \textit{ExponentialModel(amplitude, scale, spatialCorrelation)}
\item \textit{ExponentialModel(amplitude, scale, spatialCovariance)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{amplitude}: a NumericalPoint of dimension $d$, the amplitude $\vect{a}$ of the model,
\item \textit{scale}: a NumericalPoint of size $d$, the scale $\vect{\lambda}$ of the model,
\item \textit{spatialCorrelation}: a CorrelationMatrix, which is $\mat{R}$,
\item \textit{spatialCovariance}: a CovarianceMatrix , which is    $C^{stat}$
\end{description}
\bigskip

\item[Value:] an ExponentialModel
\rule{0pt}{1em}
\begin{description}
\item in the first usage, we fix the dimension to 1, scale, amplitude and spatialCorrelation to 1.0
\item in the second usage, we fix the scale  $\vect{a}$ and the amplitude  $\vect{\lambda}$. By default,  $\mat{R}=\mat{Id}(d)$. The dimension $d$ is deduced.
\item in the third usage, we fix the scale  $\vect{a}$, the amplitude  $\vect{\lambda}$ and the spatial correlation matrix  $\mat{R}$ . The dimension $d$ is deduced.
\item in the last usage, we fix the scale  $\vect{a}$, the amplitude  $\vect{\lambda}$ and the spatial covariance matrix  $C^{stat}$ . The dimension $d$ is deduced.
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{discretize}
\begin{description}
\item[Usage:] \textit{discretize(mesh)}
\item[Arguments:] \textit{mesh}: a Mesh (that can be a TimeGrid)
\item[Value:]   a CovarianceMatrix, which is defined in (\ref{covMatrix})
\end{description}
\bigskip

\item \textit{getAmplitude}
\begin{description}
\item[Usage:] \textit{getAmplitude()}
\item[Arguments:] none
\item[Value:]   a NumericalPoint, the amplitude $\vect{a}$ of the Exponential model.
\end{description}
\bigskip

\item \textit{getScale}
\begin{description}
\item[Usage:] \textit{getScale()}
\item[Arguments:] none
\item[Value:]   a NumericalPoint, the scale $\vect{\lambda}$ of the Exponential model.
\end{description}
\bigskip

\item \textit{getSpatialCorrelation}
\begin{description}
\item[Usage:] \textit{getSpatialCorrelation()}
\item[Arguments:] none
\item[Value:]   a CorrelationeMatrix, the spatial correlation matix $\mat{R}$ which gives the correlation between the i-th and j-th components at each instant $t$.
\end{description}
\bigskip

\end{description}

\end{description}

% ==================================================================================================
\newpage \subsubsection{UserDefinedCovarianceModel}

This class inherits from CovarianceModel.\\

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{UserDefinedCovarianceModel(timeGrid, covarianceCollection)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{mesh}: a Mesh which contains $N$ vertices.
\item \textit{covarianceCollection}: a collection of \textit{CovarianceMatrix} which contains  $N(N+1)/2$ covariance matrices.
\end{description}
\bigskip

\item[Value:] a UserDefinedCovarianceModel, built as follows. \\
We note $(\vect{t}_0,\dots, \vect{t}_{N-1})$ the vertices of \textit{mesh}, in $\Rset^n$ and $(\mat{C}_{k,\ell})_{0 \leq \ell \leq k \leq N-1}$ where $\mat{C}_{k,\ell} \in \mathcal{M}_{d \times d}(\Rset)$ the matrices of \textit{covarianceCollection}.\\
Care: The covariance matrices $(\mat{C}_{i,j})_{0 \leq j \leq i \leq N-1}$ must be given in the following order:
\begin{align*}
\mat{C}_{0,0}, \, \mat{C}_{1, 0}, \, \mat{C}_{1,1}, \, \mat{C}_{2,0},  \,\mat{C}_{2,1},\, \mat{C}_{2,2}, \,\dots
\end{align*}w
which corresponds to the global covariance matrix, which lower part is:
\begin{align*}
\left(
\begin{array}{cccc}
\mat{C}_{0,0}& & & \\
\mat{C}_{1,0}&  \mat{C}_{1,1}& & \\
\mat{C}_{2,0}&   \mat{C}_{2,1}& \mat{C}_{2,2}& \\
\dots & \dots & \dots & \dots
\end{array}
\right)
\end{align*}
\end{description}
Then OpenTURNS builds a covariance function which is a  piecewise constant function defined on $\cD \times \cD$ by:
\begin{align*}
\forall (\vect{s}, \vect{t}) \in \cD \times \cD, \, \quad C(\vect{s}, \vect{t}) =  \mat{C}_{k(\vect{s}),k(\vect{t})}
\end{align*}
where $k(\vect{s})$ is such that $\vect{t}_{k(\vect{s})}$ is the  vertex of $\cM$ the nearest to $\vect{s}$.\\
Concerning the  collection of covariance matrices that is used to build the discretized covariance model, we have that:
\begin{itemize}
\item the  matrix $\mat{C}_{k,\ell}$ has the index $n=\ell +\dfrac{k(k+1)}{2}$.
\item inversely, the matrix stored at index $n$ in the collection of covariance matrices, is the matrix $\mat{C}_{k,\ell}$ where:
\begin{align*}
k=\left\lfloor \dfrac{1}{2}\left( \sqrt{8n+1}-1 \right) \right\rfloor
\end{align*}
and
\begin{align*}
\ell= n-\dfrac{k(k+1)}{2}
\end{align*}
\end{itemize}
\bigskip

% ==================================================================================================
\newpage \subsubsection{UserDefinedStationaryCovarianceModel}

This class inherits from StationaryCovarianceModel.\\

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{UserDefinedStationaryCovarianceModel(mesh, covarianceCollection)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{mesh}: a Mesh which contains $N$ vertices.
\item \textit{covarianceCollection}: a collection of \textit{CovarianceMatrix} which contains  $N$ covariance matrices as the model is considered as stationary.
\end{description}
\bigskip

\item[Value:] a UserDefinedStationaryCovarianceModel, built as follows.
We note $(\vect{t}_0,\dots, \vect{t}_{N-1})$ the vertices of \textit{mesh} and $(\mat{C}_0, \dots, \mat{C}_{N-1})$ where $\mat{C}_k \in \mathcal{M}_{d \times d}(\Rset)$ for $0 \leq k \leq N-1$ the collection of covariance matrices stored in \textit{covarianceCollection}.\\

Then OpenTURNS builds a stationary covariance function which is a piecewise constant function on $\cD$ defined by:
\begin{align*}
\forall \vect{\tau} \in \cD, \, C^{stat}(\vect{\tau}) =  \mat{C}_k \mbox{ where } k \mbox{ is such that } \vect{\tau}_k \mbox{ is the  vertex of } \cM  \mbox{ the nearest to } \vect{t}.
\end{align*}

Care: in its version 1.3, OpenTURNS only implements the case $n=1$ where the mesh
$\cM$ is a regular time grid $(t_0, \dots, t_{N-1})$ discretizing $\cD=[0,T]$.


\end{description}


% =====================================================
\subsubsection{NonStationaryCovarianceModelFactory}

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{NonStationaryCovarianceModelFactory()}
\end{description}
\bigskip

\item[Value:] a NonStationaryCovarianceModelFactory
\rule{0pt}{1em}
\begin{description}
\item The implementation refers to the classical estimation of a covariance function
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{build}
\begin{description}
\item[Usage:] \textit{build(sample)}
\item[Arguments:] a ProcessSample
\item[Value:]   a CovarianceModel. Build an estimation of a CovarianceModel on the sample of fields
\end{description}
\bigskip

\item \textit{buildAsUserDefinedCovarianceModel}
\begin{description}
\item[Usage:] \textit{buildAsUserDefinedCovarianceModel(sample)}
\item[Arguments:] \textit{sample}: a ProcessSample
\item[Value:]   a UserDefinedCovarianceModel.
\end{description}
\bigskip


\end{description}


\end{description}


% =====================================================
\subsubsection{StationaryCovarianceModelFactory}

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{StationaryCovarianceModelFactory()}
\end{description}
\bigskip

\item[Value:] a StationaryCovarianceModelFactory
\rule{0pt}{1em}
\begin{description}
\item The implementation refers to the estimation of a stationary covariance function using a spectral inversion
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{build}
\begin{description}
\item[Usage:] \textit{build(sample)}
\item[Arguments:] a ProcessSample
\item[Value:]   a CovarianceModel. Build an estimation of a CovarianceModel on the sample.
\end{description}
\bigskip

\item \textit{buildAsUserDefinedStationaryCovarianceModel}
\begin{description}
\item[Usage:] \textit{buildAsUserDefinedStationaryCovarianceModel(sample)}
\item[Arguments:] \textit{sample}: a ProcessSample
\item[Value:]   a UserDefinedStationaryCovarianceModel.
\end{description}
\bigskip

\item \textit{build}
\begin{description}
\item[Usage:] \textit{build(timeSeries)}
\item[Arguments:] a TimeSeries
\item[Value:]   a CovarianceModel. Build an estimation of a CovarianceModel on the sample.
\end{description}
\bigskip

\item \textit{getSpectralModelFactory}
\begin{description}
\item[Usage:] \textit{getSpectralModelFactory()}
\item[Arguments:] None
\item[Value:]   a SpectralModelFactory. The used factory which estimate the spectrum.
\end{description}
\bigskip

\item \textit{setSpectralModelFactory}
\begin{description}
\item[Usage:] \textit{getSpectralModelFactory(factory)}
\item[Arguments:] SpectralModelFactory
\item[Value:]   None. Fix \textit{factory} as the model for estimating the spectrum.
\end{description}
\bigskip


\end{description}


\end{description}
% ==================================================================================================
\newpage
% \index{Stochastic Process!Spectral information}
\index{Spectral information}
\subsection{Spectral information}

We recall that if $X: \Omega \times\cD \rightarrow \Rset^d$ is a multivariate stochastic process of dimension $d$, where $\omega \in \Omega$ is an event, $\cD$ is a domain of $\Rset^n$, $\vect{t}\in \cD$ is a multivariate index and $X(\omega, \vect{t}) \in \Rset^d$.\\

If $X$  is a zero-mean weakly stationary continuous process and if for all $(i,j)$, $C^{stat}_{i,j}: \Rset^n \rightarrow \Rset^n$ is $\cL^1(\Rset^n)$ (ie $\int_{\Rset^n} |C^{stat}_{i,j}(\vect{\tau})|\, d\vect{\tau}\, < +\infty$),  we  define the \emph{ bilateral spectral density function} $S : \Rset^n \rightarrow \cH^+(d)$ where $\mathcal{H}^+(d) \in \mathcal{M}_d(\Cset)$ is the set of $d$-dimensional positive definite hermitian matrices, as the Fourier transform of the covariance function $C^{stat}$ :
\begin{equation} \label{specdensFunc}
\forall \vect{f} \in \Rset^n, \,S(\vect{f}) = \int_{\Rset^n}\exp\left\{  -2i\pi <\vect{f},\vect{\tau}> \right\} C^{stat}(\vect{\tau})\, d\vect{\tau}
\end{equation}

Furthermore, if for all $(i,j)$, $S_{i,j}: \Rset^n \rightarrow \Cset$ is $\cL^1(\Cset)$ (ie $\int_{\Rset^n} |S_{i,j}(\vect{f})|\, d\vect{f}\, < +\infty$), $C^{stat}$ may be evaluated from $S$ as follows :
\begin{equation} \label{cspectransform}
C^{stat}(\vect{\tau})  = \int_{\Rset^n}\exp\left\{  2i\pi <\vect{f}, \vect{\tau}> \right\}S(\vect{f})\, d\vect{f}
\end{equation}
In the discrete case, the spectral density is defined for a zero-mean weakly stationary process, where $\cD=(\delta_1 \Zset \times \dots \times \delta_n \Zset)$ with $\forall i, \delta_i >0$ and where the previous integrals are replaced by sums.




% =====================================================
\newpage
% \index{Stochastic Process!Spectral information!SpectralModel}
\index{SpectralModel}
\subsubsection{SpectralModel}

This class is the interface of SpectralModelImplementation. \\
\begin{description}

\item[Usage:]  \textit{SpectralModel(mySpectralModelImplementation)}
\bigskip

\item[Arguments:] \textit{mySpectralModelImplementation}: the implementation of a spectral model. For example, the Cauchy model.

\bigskip


\item[Value:] a SpectralModel
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{computeSpectralDensity}
\begin{description}
\item[Usage:] \textit{computeSpectralDensity(f)}
\item[Arguments:] $f$,  a NumericalScalar
\item[Value:] an HermitianMatrix of size $d$, computes the unilateral spectral function $\mat{G}(f)$ at the frequency $f$ ($f \geq 0$)
\end{description}
\bigskip


\item \textit{getDimension}
\begin{description}
\item[Usage:] \textit{getDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the dimension of the model which is $d$
\end{description}
\bigskip


\item \textit{getFrequencyGrid}
\begin{description}
\item[Usage:] \textit{getFrequencyGrid()}
\item[Arguments:] none
\item[Value:]   an RegularGrid, the frequency grid associated to the spectral model
\end{description}
\bigskip

\end{description}

\end{description}

% ==================================================================================================
\newpage
% \index{Stochastic Process!Spectral information!CauchyModel}
\index{CauchyModel}
\subsubsection{CauchyModel}
\label{cauchyMod}

This class inherit from SpectralModel class. It implements the spectral model associated to the Exponential covariance model detailed in (\ref{expModel}). The spectral density function is defined by :
\begin{equation}\label{cauchyModelUM}
S_{ij}(f) = \displaystyle \frac{4R_{ij}a_ia_j(\lambda_i+ \lambda_j)}{(\lambda_i+ \lambda_j)^2 + (4\pi f)^2}
\end{equation}
where $\mat{R}$, $\vect{a}$ and $\vect{\lambda}$ are the parameters of the Exponential covariance model. The relation (\ref{cauchyModelUM}) can be explicited with the spatial covariance function  $\mat{C}^{stat}(\tau)$ defined in (\ref{RClinkUM}).


\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{CauchyModel()}
\item \textit{CauchyModel(amplitude, scale)}
\item \textit{CauchyModel(amplitude, scale, spatialCorrelation)}
\item \textit{CauchyModel(amplitude, scale, spatialCovariance)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{amplitude}: a NumericalPoint of size $d$, the amplitude of the model in each dimension,
\item \textit{scale}: a NumericalPoint of size $d$, the scale of the model in each dimension,
\item \textit{spatialCorrelation}: a CorrelationeMatrix of size $d \ \times \  $d, the correlation between $i-th$ and $j-th$ dimension,
\item \textit{spatialCovariance}: a CovarianceMatrix of dimension $d \ \times \  d$, the correlation matrix  $\mat{C}^s$.
\end{description}

\bigskip

\item[Value:] an CauchyModel
\rule{0pt}{1em}
\begin{description}
\item in the first usage, we fix dimension to 1, scale, amplitude and spatialCorrelation to 1.0
\item in the second usage, we fix the dimension $d$, scale and amplitude values. Correlation used here is IdentityMatrix(d)
\item in the third usage, we fix the dimension, scale, amplitude and correlation.
\item in the last usage, we fix the scale  $\vect{a}$, the amplitude  $\vect{\lambda}$ and the spatial covariance matrix  $\mat{C}^s$ . The dimension $d$ is deduced.
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}
\item \textit{getAmplitude}
\begin{description}
\item[Usage:] \textit{getAmplitude()}
\item[Arguments:] none
\item[Value:]   a NumericalPoint, the amplitude of the Cauchy model in each dimension
\end{description}
\bigskip

\item \textit{getScale}
\begin{description}
\item[Usage:] \textit{getScale()}
\item[Arguments:] none
\item[Value:]   a NumericalPoint, the scale of the model in each dimension
\end{description}
\bigskip

\item \textit{getSpatialCorrelation}
\begin{description}
\item[Usage:] \textit{getSpatialCorrelation()}
\item[Arguments:] none
\item[Value:]   a CorrelationeMatrix, the correlation between the i-th and j-th dimension
\end{description}
\bigskip


\end{description}

\end{description}


% =====================================================
\newpage
% \index{Stochastic Process!Spectral information!UserDefinedSpectralModel}
\index{UserDefinedSpectralModel}
\subsubsection{UserDefinedSpectralModel}
This class inherits from SpectralModel.\\

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{UserDefinedSpectralModel()}
\item \textit{UserDefinedSpectralModel(frequency, densityCollectionFunction)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{frequency}: a RegularGrid which containing the frequency values on which the model has been built;
\item \textit{densityCollectionFunction}: a collection of \textit{HermitianMatrix} of size $d$, the density functions of the \textit{SpectralModel}

\end{description}

\bigskip

\item[Value:] a UserDefinedSpectralModel
\rule{0pt}{1em}
\begin{description}
\item in the second usage, we fix the spectral density function over the frequency grid \textit{frequency}
\end{description}
\bigskip

\item[Description:]  \rule{0pt}{1em}
The class enables user to quickly implement a \textit{SpectralModel} from retrn of experience in their area by fixing a regular frequency grid and matrices collection.\\
This class is also used for the estimation of a \textit{SpectralModel}


\end{description}

% =====================================================
\newpage
% \index{Stochastic Process!Spectral information!SpectralModelFactory}
\index{SpectralModelFactory}
\subsubsection{SpectralModelFactory}

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{SpectralModelFactory()}
\item \textit{SpectralModelFactory(mySpectralModelFactoryImplementation)}
\end{description}
\bigskip

\item[Arguments:]  \textit{mySpectralModelFactoryImplementation}: a \textit{SpectralModelFactoryImplementation} which is  the specific spectral model factory used. By default,the implementation is the \textit{WelchFactory} one. By default,the implementation is the \textit{WelchFactory} one.
\bigskip


\item[Value:] a \textit{SpectralModelFactory}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{build}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{build(ts)}
\item \textit{build(ps)}
\end{description}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item $ts$ : a TimeSeries
\item $ps$ : a ProcessSample
\end{description}
\item[Value:]   a \textit{SpectralModel}, the  spectral model estimated from the data
\end{description}
\bigskip


\item \textit{getFFTAlgorithm}
\begin{description}
\item[Usage:] \textit{getFFTAlgorithm()}
\item[Arguments:] none
\item[Value:]   a FFT, the used FFT algorithm for the Fourier transform
\end{description}
\bigskip

\item \textit{getFrequencyGrid}
\begin{description}
\item[Usage:] \textit{getFrequencyGrid()}
\item[Arguments:] none
\item[Value:]   a \textit{RegularGrid}, the grid on which the  spectral model is estimlated from data.
\end{description}
\bigskip

\item \textit{setFFTAlgorithm}
\begin{description}
\item[Usage:] \textit{setFFTAlgorithm(fft)}
\item[Arguments:] an FFT
\item[Value:]   set \textit{fft} as the algorithm for the Fourier transform
\end{description}
\bigskip

\item \textit{setFrequencyGrid}
\begin{description}
\item[Usage:] \textit{setFrequencyGrid(myGrid)}
\item[Arguments:] \textit{myGrid}: a \textit{RegularGrid}
\item[Value:]   none. It sets the grid specified by the User.
\end{description}


\end{description}


\end{description}

% ==================================================================================================
\newpage
% \index{Stochastic Process!Spectral information!WelchFactory}
\index{WelchFactory}
\subsubsection{WelchFactory}

This class inherits from \textit{SpectralModelFactory}.
It implements the \textit{Welch} method.
\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{WelchFactory()}
\item \textit{WelchFactory(window, bloc, overlap)}
\end{description}
\bigskip

\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{window}: a \textit{FilteringWindows} which is the window considered
\item \textit{bloc}:
\item \textit{overlap}:
\end{description}
\bigskip

\item[Value:] a WelchFactory
\rule{0pt}{1em}
\begin{description}
\item With the first usage, the Hanning is fixed as the window, the number of blocs is 1 and overlap = 0
\item In the second usage, we fix the filtering window, the number of blocs and the overlap parameter
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}


\item \textit{getFilteringWindows}
\begin{description}
\item[Usage:] \textit{getFilteringWindows()}
\item[Arguments:] none
\item[Value:]  a FilteringWindows. The used window algorithm
\end{description}
\bigskip

\item \textit{setFilteringWindows}
\begin{description}
\item[Usage:] \textit{setFilteringWindows(window)}
\item[Arguments:] window, a FilteringWindows
\item[Value:]    Set window as the FilteringWindows
\end{description}
\bigskip

\item \textit{getBloc}
\begin{description}
\item[Usage:] \textit{getBloc()}
\item[Arguments:] none
\item[Value:]  an integer. The number of blocs of the Welch method
\end{description}
\bigskip

\item \textit{setBloc}
\begin{description}
\item[Usage:] \textit{setBloc(bloc)}
\item[Arguments:] bloc, an integer
\item[Value:]  Set the number of blocs
\end{description}
\bigskip

\item \textit{getOverlap}
\begin{description}
\item[Usage:] \textit{getOverlap()}
\item[Arguments:] none
\item[Value:]  an integer. The size of overlap within the Welch method
\end{description}
\bigskip

\item \textit{setOverlap}
\begin{description}
\item[Usage:] \textit{setOverlap(overlap)}
\item[Arguments:] overlap, an integer
\item[Value:]  Set the size of the overlap
\end{description}
\bigskip

\end{description}


\end{description}


% =====================================================
\newpage
% \index{Stochastic Process!Spectral information!FilteringWindows}
\index{FilteringWindows}
\subsubsection{FilteringWindows}


\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{FilteringWindows()}
\end{description}
\bigskip


\item[Value:] a FilteringWindows
\rule{0pt}{1em}
\begin{description}
\item The FilteringWindows is built over the interval $[0, 1]$. This class is the interface of \textit{FilteringWindowsImplementation}
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{()} operator
\begin{description}
\item[Usage:] \textit{($\alpha$)}
\item[Arguments:] \textit{$\alpha$}, a NumericalScalar
\item[Value:]  a NumericalScalar, the evaluation of the filtering windows on $\alpha$
\end{description}
\bigskip

\item \textit{getName}
\begin{description}
\item[Usage:] \textit{getName()}
\item[Arguments:] none
\item[Value:]  a string, the name of the filtering windows
\end{description}
\bigskip

\item \textit{setName}
\begin{description}
\item[Usage:] \textit{setName(name)}
\item[Arguments:] name, a string
\item[Value:]  the filtering windows is named \textit{name}
\end{description}
\bigskip

\end{description}


\end{description}

% =====================================================
\newpage
% \index{Stochastic Process!Spectral information!Hanning}
\index{Hanning}
\subsubsection{Hanning}

The Hanning filtering windows inherits from the FilteringWindows class

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{Hanning()}
\end{description}
\bigskip


\item[Value:] a Hanning
\rule{0pt}{1em}
\bigskip

\item[Description:]  \rule{0pt}{1em}

The Hanning windows is implemented using the formula $w(t) =  \sqrt{\dfrac{8}{3}} \sin(\pi t)^2\fcar{[0,1]}{t}$.


\end{description}


% =====================================================
\newpage
% \index{Stochastic Process!Spectral information!Hamming}
\index{Hamming}
\subsubsection{Hamming}
The Hamming filtering windows inherits from the FilteringWindows class

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{Hamming()}
\end{description}
\bigskip


\item[Value:] a Hamming
\rule{0pt}{1em}
\bigskip

\item[Description:]  \rule{0pt}{1em}

The Hamming windows is implemented using the formula : \\ $w(t) =  C(\alpha - (1-\alpha)\cos(2\pi t))\fcar{[0,1]}{t}$ with $C = \frac{1}{\alpha^2 + (1-\alpha)^2/2}$ and $\alpha=25/46$. This value of $\alpha$ minimizes the amplitude of the first side lobe of its Fourier transform.\\
The normalization constant $C$ is such that $\int_{0}^{1} w(t)^2 dt = 1 $


\end{description}



% =====================================================
\newpage
% \index{Stochastic Process!Link temporal - spectral information}
\subsection{Link Temporal - Spectral information}

% \index{Stochastic Process!Link temporal - spectral information!SecondOrderModel}
\index{SecondOrderModel}
\subsubsection{SecondOrderModel}

The class is the interface of SecondOrderModelImplementation. \\
This aims at regrouping a \textit{StationaryCovarianceModel} and a \textit{SpectralModel} that are in correspondence.\\
The issued SecondOrderModel both has spectral and covariance functions. \\ \\

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{SecondOrderModel()}
\item \textit{SecondOrderModel(stationaryCovarianceModel, spectralModel)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}

\bigskip

\item[Value:] a SecondOrderModel
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

The methods of the SecondOrderModel are both those implemented for StationaryCovarianceModel and SpectralModel.

\begin{description}

\item \textit{getDimension}
\begin{description}
\item[Usage:] \textit{getDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the dimension of the model $d$
\end{description}
\bigskip

\item \textit{computeCovariance}
\begin{description}
\item[Usage:] \textit{computeCovariance(tau)}
\item[Arguments:] $t$ : NumericalScalar
\item[Value:] a CovarianceMatrix of size $d\times d$, computes the covariance function for different \textit{tau}
\end{description}
\bigskip

\item \textit{discretizeCovariance}
\begin{description}
\item[Usage:] \textit{discretizeCovariance(tg)}
\item[Arguments:] $tg$ :  a RegularGrid
\item[Value:] a CovarianceMatrix (of size $d\times  n$), with $n$ the size of the time grid,
which is the discretization of the covariance function on the time grid $tg$.
\end{description}
\bigskip

\item \textit{computeSpectralDensity}
\begin{description}
\item[Usage:] \textit{computeSpectralDensity(f)}
\item[Arguments:] $f$,  a NumericalScalar
\item[Value:] an HermitianMatrix of size $d \times d$, computes the unilateral spectral density model $\mat{G}$ at the frequency $f$ ($f \geq 0$)
\end{description}
\bigskip

\item \textit{getSpectralModel}
\begin{description}
\item[Usage:] \textit{getSpectralModel()}
\item[Arguments:] none
\item[Value:] a SpectralModel, the spectral model of the SecondOrderModel
\end{description}
\bigskip

\item \textit{setSpectralModel}
\begin{description}
\item[Usage:] \textit{setSpectralModel(spectralModel)}
\item[Arguments:] a SpectralModel
\item[Value:] set \textit{spectralModel} as the spectral model  of the SecondOrderModel
\end{description}
\bigskip

\item \textit{getStationaryCovarianceModel}
\begin{description}
\item[Usage:] \textit{getStationaryCovarianceModel()}
\item[Arguments:] none
\item[Value:] a StationaryCovarianceModel, the covariance function of the SecondOrderModel
\end{description}
\bigskip

\item \textit{setStationaryCovarianceModel}
\begin{description}
\item[Usage:] \textit{setStationaryCovarianceModel(covarianceModel)}
\item[Arguments:] a StationaryCovarianceModel
\item[Value:] sets \textit{covarianceModel} as the covariance function of the SecondOrderModel
\end{description}
\bigskip

\item \textit{getName}
\begin{description}
\item[Usage:] \textit{getName()}
\item[Arguments:] none
\item[Value:] a string, the name of the SecondOrderModel
\end{description}
\bigskip

\item \textit{setName}
\begin{description}
\item[Usage:] \textit{setName(name)}
\item[Arguments:] name : a string
\item[Value:] the SecondOrderModel, named \textit{name}
\end{description}
\bigskip


\end{description}

\end{description}

% ==================================================================================================
\newpage
% \index{Stochastic Process!Link temporal - spectral information!ExponentialCauchy}
\index{ExponentialCauchy}
\subsubsection{ExponentialCauchy}

This class inherit from SecondOrderModel class.\\
It aims at regrouping the Exponential Model of the covariance function defined in (\ref{expModel}) and the Cauchy Model for the spectral density function defined in (\ref{cauchyMod}).



\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{ExponentialCauchy()}
\item \textit{ExponentialCauchy(amplitude, scale)}
\item \textit{ExponentialCauchy(amplitude, scale, spatialCorrelation)}
\item \textit{ExponentialCauchy(amplitude, scale, spatialCovariance)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{amplitude}: a NumericalPoint of size $d$, the amplitude of the model in each dimension.
\item \textit{scale}: a NumericalPoint of size $d$, the scale of the model in each dimension.
\item \textit{spatialCorrelation}: a CorrelationeMatrix of size $d  \times   d$, the correlation between the $i-th$ and $j-th$ dimension.
\item \textit{spatialCovariance}: a CovarianceMatrix of dimension $d  \times   d$, the correlation matrix  $\mat{C}^{stat}$.
\end{description}

\bigskip

\item[Value:] an ExponentialCauchy
\rule{0pt}{1em}
\begin{description}
\item in the first usage, we fix dimension to $1$, scale amplitude and spatialCorrelation to 1.0
\item in the second usage, we fix the dimension, scale and amplitude values. spatialCorrelation here is IdentityMatrix(d)
\item in the third usage, we fix the dimension, scale, amplitude and correlation.
\item in the last usage, we fix the scale  $\vect{a}$, the amplitude  $\vect{\lambda}$ and the spatial covariance matrix  $\mat{C}^{stat}$ . The dimension $d$ is deduced.
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getAmplitude}
\begin{description}
\item[Usage:] \textit{getAmplitude()}
\item[Arguments:] none
\item[Value:]   a NumericalPoint, the amplitude of the Exponential model in each dimension
\end{description}
\bigskip

\item \textit{getScale}
\begin{description}
\item[Usage:] \textit{getScale()}
\item[Arguments:] none
\item[Value:]   a NumericalPoint, the scale of the Exponential model in each dimension
\end{description}
\bigskip

\item \textit{getSpatialCorrelation}
\begin{description}
\item[Usage:] \textit{getSpatialCorrelation()}
\item[Arguments:] none
\item[Value:]   a CorrelationeMatrix, the correlation between the i-th and j-th dimension
\end{description}
\bigskip

\end{description}

\item[Remark:]  \rule{0pt}{1em}

The class regroups the \textit{ExponentialModel} and \textit{CauchyModel} of same parameters.\\
The density function is, from a mathematical point of view, the Fourier transform of the CovarianceModel.

\end{description}

% ================================================================================================================

\newpage
% \index{Stochastic Process!Normal process}
\subsection{Normal process}

The class \textit{NormalProcess} inherits form \textit{Process}



% =====================================================

\newpage
% \index{Stochastic Process!Normal process!SpectralNormalProcess}
\index{SpectralNormalProcess}

\subsubsection{SpectralNormalProcess}

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{SpectralNormalProcess()}
\item \textit{SpectralNormalProcess(model, timeGrid)}
\item \textit{SpectralNormalProcess(model, maximalFrequency, N)}
\item \textit{SpectralNormalProcess(spectralModel, timeGrid)}
\item \textit{SpectralNormalProcess(spectralModel, maximalFrequency, N)}

\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{spectralModel}: a SpectralModel
\item \textit{model}: a SecondOrderModel
\item \textit{timeGrid}: a RegularGrid; the time grid associated to the process. OpenTURNS has only implemented the algorithm when the mesh is a regular grid.
\item \textit{maximalFrequency}: a NumericalScalar; the maximal frequency
\item $N$ : an integer; the size of discretization of the frequency domain
\end{description}
\bigskip

\item[Value:] a SpectralNormalProcess process
\rule{0pt}{1em}
\begin{description}
\item in the second usage, we fix the time grid and the second order model (spectral density model) which implements the process; Frequency values are induced by the time values.
\item in the third usage, conversely to the previous usage, the process is fixed in the frequency domain. \textit{maximalFrequency} value and $N$ induce the time grid.\\
Be aware that the maximal frequency used in the computation is not \textit{maximalFrequency} but $(1-1/N)maximalFrequency$.
\item in the fouth usage (respectively the fifth usage), the spectral model is given instead of a complet second order model and the other arguments are the same
as the second (respectively the third) usage.
\end{description}
\bigskip

\item[Comments:]
\rule{0pt}{1em}

The SpectralNormalProcess enables to model the normal processes in the spectral domain.
This class inherits from the NormalProcess class.  \\
The first call of \textit{getRealization} might be time consuming because it computes $N$ hermitian matrices of size $d \times \ d$, where $d$ is the dimension of the spectral model.
These matrices are factorized and stored in order to be used for each call of the \textit{getRealization} method.

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getFrequentialGrid}
\begin{description}
\item[Usage:] \textit{getFrequentialGrid()}
\item[Arguments:] none
\item[Value:] a  \textit{RegularGrid}, the frequencies used in the computation.
\end{description}
\bigskip

\item \textit{getFrequencyStep}
\begin{description}
\item[Usage:] \textit{getFrequencyStep()}
\item[Arguments:] none
\item[Value:] a  NumericalScalar whioch is the frequency step of the frequency grid.
\end{description}
\bigskip

\end{description}

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Stochastic Process!Normal process!TemporalNormalProcess}
\index{TemporalNormalProcess}
\subsubsection{TemporalNormalProcess}

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{TemporalNormalProcess()}
\item \textit{TemporalNormalProcess(model, timeGrid)}
\item \textit{TemporalNormalProcess(covarianceModel, mesh)}
\item \textit{TemporalNormalProcess(trend, covarianceModel, mesh)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{covarianceModel}: a StationaryCovarianceModel
\item \textit{model}: a SecondOrderModel
\item \textit{trend}: a TrendTransform, the trend fucntion of the process
\item \textit{timeGrid}: a RegularGrid, the time grid associated to the process.
\item \textit{mesh}: a Mesh, the mesh associated to the process.
\end{description}
\bigskip

\item[Value:] a TemporalNormalProcess process
\rule{0pt}{1em}
\begin{description}
\item in the second usage, we fix the time grid and the second order model (the associated temporal covariance model and  spectral one). In that case, the process must be defined on a mesh which is a regular grid.
\item in the third usage, we fix the temporal covariance model and the mesh which can be of any dimension.
\item in the lats usage, we add a trend to the process. By default, the trend is null.
\end{description}
\bigskip

\item[Comments:]
\rule{0pt}{1em}
This class inherits from the NormalProcess class. The initialization stores the second model in order to reuse it for the realizations. \\
When calling the {\itshape getRealization} method, the first call might be time consuming because it calls the {\itshape discretizeCovariance} method of the covariance model  in order to compute the covariance model on the mesh and get its Cholesky factor. This is done once only.

\end{description}



% =====================================================
\newpage
% \index{Stochastic Process!ARMA}
\subsection{ARMA}


We suppose that the stochastic process $(\vect{X}_t)_t$ follows the linear recurrence :
\begin{equation}\label{dimnUM}
\vect{X}_t + \mat{A}_{\, 1}   \,  \vect{X}_{t-1} + \hdots +  \mat{A}_{\, p} \,   \vect{X}_{t-p} =
\vect{\varepsilon}_{t}+  \mat{B}_ {\, 1} \,   \vect{\varepsilon}_{t-1}+   \hdots + \mat{B}_{\, q}  \,  \vect{\varepsilon}_{t-q}
\end{equation}
that writes in dimension 1 :

\begin{equation}\label{dim1UM}
X_t +a_1  X_{t-1} + \hdots +  a_p X_{t-p} =
\varepsilon_{t}+  b_1 \varepsilon_{t-1}+   \hdots +b_q \varepsilon_{t-q}
\end{equation}
where $(a_i,b_i) \in \Rset$.\\

This class inherits from \textit{Process}

\newpage
% \index{Stochastic Process!ARMA!ARMA}
\index{ARMA}
\subsubsection{ARMA}
\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{ARMA()}
\item \textit{ARMA(ARCoefficients, MACoefficients, whiteNoise)}
\item \textit{ARMA(ARCoefficients, MACoefficients, whiteNoise, state)}

\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{ARCoefficients}: an ARMACoefficients , the coefficients of the AR part of the recurrence : $(a_1, \hdots, a_p)$ of (\ref{dim1UM}) and $( \mat{A}_{\, 1}, \hdots, \mat{A}{\, _p})$ of  (\ref{dimnUM}).
\item \textit{MACoefficients}: an ARMACoefficients , the coefficients of the MA part of the recurrence : $(b_1, \hdots, b_q)$  of (\ref{dim1UM}) and $( \mat{B}_{\, 1}, \hdots, \mat{B}{\, _q})$ of  (\ref{dimnUM}).
\item \textit{whiteNoise}: a WhiteNoise, the white noise used for the random noise $\varepsilon$.
\item \textit{state}: an ARMAState , the state of the ARMA process ie the last values pf the process.
\end{description}
\bigskip

\item[Value:] an ARMA process
\rule{0pt}{1em}
\begin{description}
\item in the first usage, an $ARMA(0,0)$  is built with default options : the time grid is $\{0,1\}$, and the  $\varepsilon$ distribution is $\cN(0,1)$.
\item in the second usage, we fix the coefficients of the linear recurrence (and the dimension of the process is deduced) and the distribution of the  random noise $\varepsilon$.
\item in the third usage, we  also fix the initial state which is the last  $p$ values of the process and the last $q$ values of the noise.
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getARCoefficients}
\begin{description}
\item[Usage:] \textit{getARCoefficients()}
\item[Arguments:] none
\item[Value:] an ARMACoefficients, the coefficients of the linear recurrence.
\end{description}
\bigskip

\item \textit{getMACoefficients}
\begin{description}
\item[Usage:] \textit{getMACoefficients()}
\item[Arguments:] none
\item[Value:] an ARMACoefficients, the coefficients of the linear recurrence.
\end{description}
\bigskip


\item \textit{getFuture}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{getFuture($N_{it}$)}
\item \textit{getFuture($N_{it}$,$N_{real}$)}
\end{description}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{$N_{it}$}: an integer, the number of future instants where the process is extended
\item \textit{$N_{real}$}: an integer, the number of futures that are evaluated
\end{description}
\item[Value:]\rule{0pt}{1em}
\begin{description}
\item   in the first usage, a TimeSeries, which is one possible realization of the future using the current state of the process over the $N_{it}$ next instants.
\item in the second usage, a ProcessSample, which contains $N_{real}$ possible realizations of the future of the process on the $N_{it}$ next instants. Note that the time grid of each possible future begins at the last instant of the time grid associated to the time series which is extended.
\end{description}
\end{description}
\bigskip


\item \textit{getState}
\begin{description}
\item[Usage:] \textit{getState()}
\item[Arguments:] none
\item[Value:] an ARMAState, the state of the ARMA  which is the last  $p$ values of the process and the last $q$ values of the  random noise $\varepsilon$.
\end{description}
\bigskip

\item \textit{getWhiteNoise}
\begin{description}
\item[Usage:] \textit{getWhiteNoise()}
\item[Arguments:] none
\item[Value:] a WhiteNoise,  the white noise $\varepsilon$ of (\ref{dimnUM}).
\end{description}
\bigskip

\item \textit{setWhiteNoise}
\begin{description}
\item[Usage:] \textit{setWhiteNoise(whiteNoise)}
\item[Arguments:] \textit{whiteNoise}, a WhiteNoise
\item[Value:] Fix the white noise $\varepsilon$ of (\ref{dimnUM}).
\end{description}
\bigskip

\item \textit{computeNThermalization}
\begin{description}
\item[Usage:] \textit{computeNThermalization($\varepsilon$)}
\item[Arguments:] \textit{$\varepsilon$}, a positive real
\item[Value:] an integer, the number of iterations of the ARMA process before being stationary and independent of its current state evaluated with the precision $\varepsilon$ :
\begin{equation}\label{nTher}
N_{ther} > E[ \displaystyle \frac{\ln  \varepsilon}{\ln \max_{i,j} |r_{ij}|}]
\end{equation}
where  $E[]$ is the integer part and the $r_i$ are the roots of the polynomials (given here ion dimension 1) :
\begin{equation}\label{PolPhi}
\Phi(\vect{r}) = \vect{r}^p + \sum_{i=1}^p a_i\vect{r}^{p-i}
\end{equation}


\end{description}
\bigskip

\item \textit{getNThermalization}
\begin{description}
\item[Usage:] \textit{getNThermalization()}
\item[Arguments:] none
\item[Value:] an integer, the number of iterations that the ARMA process uses before being independent from its actual state evaluated with the default precision  $\varepsilon = 2^{-53} \equiv 10^{-16}$.
\end{description}
\bigskip

\item \textit{setNThermalization}
\begin{description}
\item[Usage:] \textit{setNThermalization(n)}
\item[Arguments:] $n$, an intger
\item[Value:] Set the number of iterations of initialization for the ARMA process
\end{description}
\bigskip

\end{description}

\end{description}


% =====================================================
\newpage
% \index{Stochastic Process!ARMACoefficients}
\index{ARMACoefficients}
\subsubsection{ARMACoefficients}


\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{ARMACoefficients(size, dimension)}
\item \textit{ARMACoefficients(point)}
\item \textit{ARMACoefficients(collection)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{size}: an integer, the number of elements of the ARMACoefficients class
\item \textit{dimension}: an integer, the dimension of each coefficient
\item \textit{point}: a NumericalPoint, the coefficients of the recurrence (in dimension 1)
\item \textit{collection}: a SquareMatrixCollection which contains SquareMatrix of same dimension
\end{description}
\bigskip

\item[Value:] an ARMACoefficients
\rule{0pt}{1em}
\begin{description}
\item in the first usage, we fix the dimension and the number of elements.
\item in the second usage, we fix the dimension to 1 and we get the coefficients of the recurrence
\item in the third usage, we get the coefficients of the recurrence as matrix (and so the dimension)
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getSize}
\begin{description}
\item[Usage:] \textit{getSize()}
\item[Arguments:] none
\item[Value:]   an integer, the size of the ARMACoefficients (number of coefficients)
\end{description}
\bigskip

\item \textit{getDimension}
\begin{description}
\item[Usage:] \textit{getDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the dimension each coefficients
\end{description}
\bigskip

\item \textit{add}
\begin{description}
\item[Usage:] \textit{add(coefficient)}
\item[Arguments:] \textit{coefficient}: a SquareMatrix
\item[Value:]    an ARMACoefficients of size  $size +1$
\end{description}
\bigskip

\item \textit{getName}
\begin{description}
\item[Usage:] \textit{getName()}
\item[Arguments:] none
\item[Value:] a string, the name of the ARMACoefficients
\end{description}
\bigskip

\item \textit{setName}
\begin{description}
\item[Usage:] \textit{setName(name)}
\item[Arguments:] name : a string
\item[Value:] the ARMACoefficients is named \textit{name}
\end{description}
\bigskip


\end{description}

\end{description}



% =====================================================
\newpage
% \index{Stochastic Process!ARMAState}
\index{ARMAState}
\subsubsection{ARMAState}


\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{ARMAState(values, noise)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{values}: a NumericalSample, last observations of an ARMA process
\item \textit{noise}  : a NumericalSample, last observations of a random noise
\end{description}
\bigskip

\item[Value:] an ARMAState
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getSize}
\begin{description}
\item[Usage:] \textit{getSize()}
\item[Arguments:] none
\item[Value:]   an integer, the size of the ARMACoefficients (number of coefficients)
\end{description}
\bigskip

\item \textit{getDimension}
\begin{description}
\item[Usage:] \textit{getDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the dimension of the state (and thus of the process)
\end{description}
\bigskip

\item \textit{getX}
\begin{description}
\item[Usage:] \textit{getX()}
\item[Arguments:] none
\item[Value:] a NumericalSample (of size $p$), the last $p$ values of the ARMA
\end{description}
\bigskip

\item \textit{getEpsilon}
\begin{description}
\item[Usage:] \textit{getEpsilon()}
\item[Arguments:] none
\item[Value:] a NumericalSample (of size $q$), the last $q$ noise values of the ARMA
\end{description}
\bigskip

\item \textit{setX}
\begin{description}
\item[Usage:] \textit{setX(myLastProcessValues)}
\item[Arguments:] \textit{myLastValues}, a NumericalSample of size $p$
\item[Value:] None. We fix the last $p$ values of the process
\end{description}
\bigskip

\item \textit{setEpsilon}
\begin{description}
\item[Usage:] \textit{setEpsilon(myLastNoiseValues)}
\item[Arguments:] \textit{myLastNoiseValues}, a NumericalSample of size $q$
\item[Value:] None. We fix the last $q$ values of the random noise
\end{description}
\bigskip

\item \textit{getName}
\begin{description}
\item[Usage:] \textit{getName()}
\item[Arguments:] none
\item[Value:] a string, the name of the ARMAState
\end{description}
\bigskip

\item \textit{setName}
\begin{description}
\item[Usage:] \textit{setName(name)}
\item[Arguments:] name : a string
\item[Value:] the ARMAState is named \textit{name}
\end{description}

\end{description}

\end{description}

% =====================================================
\newpage
% \index{Stochastic Process!ARMA!BoxCoxFactory}
\index{BoxCoxFactory}
\subsubsection{BoxCoxFactory}

\begin{description}

\item[Usage:] \textit{BoxCoxFactory()}


\item[Arguments:]  none


\item[Value:] a BoxCoxFactory

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{build}
\begin{description}

\item[Usage:]
\rule{0pt}{1em}
\begin{description}
\item \textit{build(inTS)}
\item \textit{build(inTS, shift)}
\item \textit{build(inTS, shift, likelihoodGraph)}
\item \textit{build(inNS)}
\item \textit{build(inNS, shift)}
\item \textit{build(inNS, shift, likelihoodGraph)}
\end{description}

\item[Arguments:]   \rule{0pt}{1em}
\begin{description}
\item \textit{inTS}: a TimeSeries , the time series from which the Box Cox transformation parameter is estimated
\item  \textit{inNS}: a NumericalSample
\item  \textit{shift}: a NumericalPoint that ensures that when shifted, the
data are all positive. If not precised, OpenTURNS uses the opposite of the min vector of the data if some data are negative.
\item \textit{likelihoodGraph}: an emptyGraph that is fulfilled when the
\textit{build} method has benn called.
\end{description}

\item[Value:]  a BoxCoxTransform which enables to transform the time series  $\vect{Y}_t$ into $\vect{Z}_t$ such that  $\Var{\vect{Z}_t}$ is constant  with respect to the time. The Box Cox transformation writes:
\begin{eqnarray}
\label{BoxCoxModel}
\Rset \times \Rset^{p} & \rightarrow & \Rset^{p} \\ \nonumber
(t_i,\vect{y}_{t_i})  & \mapsto & h_{\vect{\lambda}}(\vect{y}_{t_i} + \vect{\alpha})
\end{eqnarray}
where $\vect{\alpha}$ is the shift fixed by the User or evaluated by OpenTURNS if not fixed by the user and necessary. Each marginal of  the $ h_{\vect{\lambda}}$ transformation writes:
\begin{eqnarray}
\label{hLambda}
h_\lambda(y) & = &
\left\{
\begin{array}{ll}
\dfrac{y^\lambda-1}{\lambda} & \lambda \neq 0 \\
\log(y)                        & \lambda = 0
\end{array}
\right.
\end{eqnarray}
In the multivariate case, OpenTURNS proceeds component by component. \\
When the empty graph \textit{likelihoodGraph} is precised, it is fulfilled
with the evolution of the likelihood with respect to the value of
$\lambda_i$ for each component  $i$. It enables to graphically detect the optimal values.
\end{description}
\bigskip


\item \textit{getName}
\begin{description}
\item[Usage:] \textit{getName()}
\item[Arguments:] none
\item[Value:] a string, the name of the BoxCoxFactory
\end{description}
\bigskip

\item \textit{setName}
\begin{description}
\item[Usage:] \textit{setName(name)}
\item[Arguments:] name : a string
\item[Value:] the BoxCoxFactory is named \textit{name}
\end{description}
\bigskip


\end{description}

\end{description}


% =====================================================
\newpage
% \index{Stochastic Process!ARMA!BoxCoxTransform}
\index{BoxCoxTransform}
\subsubsection{BoxCoxTransform}

This class inherits from \textit{SpatialFunction}.

A univariate Box Cox transformation $h: \Rset \rightarrow \Rset^d$  is defined by:

\begin{eqnarray}
\label{BoxCoxModel}
h_\lambda(y) & = &
\left\{
\begin{array}{ll}
\frac{y^\lambda-1}{\lambda} & \lambda \neq 0 \\
\log(y)                      & \lambda = 0
\end{array}
\right.
\end{eqnarray}
where $\lambda = 1-\frac{\beta}{2}$.

A multivariate Box Cox transformation $h: \Rset^d \rightarrow \Rset^d$  is defined by its marginal functions as (\ref{BoxCoxModel}) and the parameter $\vect{\lambda}$ is the concatenation of the marginal $\lambda_i$.


For fields of dimension $d>1$, OpenTURNS operates component by component.

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{BoxCoxTransform()}
\item \textit{BoxCoxTransform(lambda)}
\item \textit{BoxCoxTransform(lambda, shift)}
\item \textit{BoxCoxTransform(lambdaVector)}
\item \textit{BoxCoxTransform(lambdaVector, shiftVector)}
\end{description}
\bigskip



\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{lambda}: a scalar.
\item \textit{lambdaVector}: a NumericalPoint.
\item \textit{shift}: a scalar.
\item \textit{shiftVector}: a NumericalPoint.
\end{description}
\bigskip

\item[Value:] a BoxCoxTransform that contains the Box Cox transformation defined in (\ref{BoxCoxModel}) and its inverse where $\alpha=lambda$ or  $\vect{\lambda}=lambdaVector$. When the argument \textit{shift} or \textit{shiftVector} is not fixed, we take $\alpha=0$ or $\vect{\alpha}=0$.
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item $()$
\begin{description}
\item[Usage:] \textit{(y)}
\item[Arguments:] $y$ : a Field, the field $(\vect{y}_{0}, \dots,\vect{y}_{N-1})$ with stabilized variance
\item[Value:]   a Field, noted $(\vect{z}_{0}, \dots,\vect{z}_{N-1})$  such that for each vertex $\vect{t}_i$, defined by:
\begin{align}
\vect{z}_{i} = h_{\vect{\lambda}}(\vect{y}_{i}+\vect{\alpha})
\end{align}

\end{description}
\bigskip

\item \textit{getInverse}
\begin{description}
\item[Usage:] \textit{getInverse()}
\item[Arguments:] none
\item[Value:]   an InverseBoxCoxTransform, the inverse Box Cox transformation that computes the function wich maps the field  $(\vect{z}_{0}, \dots,\vect{z}_{N-1})$ into the field $(\vect{y}_{0}, \dots,\vect{y}_{N-1})$ defined by:
\begin{align}
\vect{y}_{i} = h^{-1}_{\vect{\lambda}}(\vect{z}_{i})-\vect{\alpha}
\end{align}
\end{description}
\bigskip

\item \textit{getLambda}
\begin{description}
\item[Usage:] \textit{getLambda()}
\item[Arguments:] none
\item[Value:]   a NumericalPoint. The parameter $\vect{\lambda}$.
\end{description}
\bigskip

\item \textit{getShift}
\begin{description}
\item[Usage:] \textit{getShift()}
\item[Arguments:] none
\item[Value:]   a NumericalPoint. The parameter \textit{shiftVector}.
\end{description}
\bigskip

\item \textit{getInputDimension}
\begin{description}
\item[Usage:] \textit{getInputDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the dimension $d$
\end{description}
\bigskip

\item \textit{getOutputDimension}
\begin{description}
\item[Usage:] \textit{getOutputDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the dimension $d$
\end{description}


\end{description}

\end{description}

% =====================================================
\newpage
% \index{Stochastic Process!ARMA!InverseBoxCoxTransform}
\index{InverseBoxCoxTransform}
\subsubsection{InverseBoxCoxTransform}


This class inherits from \textit{SpatialFunction}. \\
The inverse of the Box Cox transformation defined in (\ref{BoxCoxModel}). Each marginal writes:
\begin{eqnarray}
\label{InverseBoxCoxModel}
h^{-1}_{\lambda}(y) & = &
\left\{
\begin{array}{ll}
\displaystyle (\lambda y + 1)^{\frac{1}{\lambda}} -\alpha& \lambda \neq 0 \\
\displaystyle \exp(y)-\alpha                      & \lambda = 0
\end{array}
\right.
\end{eqnarray}




\begin{description}

\item[Usage:] \rule{0pt}{1em} Generally, it is obtained as the result of a \textit{BoxCoxTransform.getInverse()}. But it is possible to directly define the inverse transformation.
\begin{description}
\item \textit{InverseBoxCoxTransform()}
\item \textit{InverseBoxCoxTransform(lambda)}
\item \textit{InverseBoxCoxTransform(lambda, shift)}
\item \textit{InverseBoxCoxTransform(lambdaVector)}
\item \textit{InverseBoxCoxTransform(lambdaVector, shiftVector)}
\end{description}
\bigskip


\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{lambda}: a scalar.
\item \textit{lambdaVector}: a NumericalPoint.
\item \textit{shift}: a scalar.
\item \textit{shiftVector}: a NumericalPoint.
\end{description}
\bigskip

\item[Value:] an InverseBoxCoxTransform, the inverse Box Cox transformation which marginals are defined in (\ref{InverseBoxCoxModel}).  $\alpha=shift$ or  $\vect{\alpha}=shiftVector$ when fixed by the User. Otherwise, $\alpha=0$ or  $\vect{\alpha}=\vect{0}$.


\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item $() $
\begin{description}
\item[Usage:] \textit{(Z)}
\item[Arguments:] $Z$ : Field, the field $(\vect{z}_{0}, \dots,\vect{z}_{N-1})$.
\item[Value:]   a Field, the field  $(\vect{y}_{0}, \dots,\vect{y}_{N-1})$ defined by:
\begin{align}
\vect{y}_{i} = h^{-1}_{\vect{\lambda}}(\vect{z}_{i})-\vect{\alpha}
\end{align}
\end{description}
\bigskip



\item \textit{getInverse}
\begin{description}
\item[Usage:] \textit{getInverse()}
\item[Arguments:] none
\item[Value:]   a \textit{BoxCoxTransform}, that corresponds to the direct Box-Cox transformation.
\end{description}
\bigskip


\item \textit{getShift}
\begin{description}
\item[Usage:] \textit{getShift()}
\item[Arguments:] none
\item[Value:]   a NumericalPoint. The parameter \textit{shiftVector}.
\end{description}
\bigskip


\item \textit{getLambda}
\begin{description}
\item[Usage:] \textit{getLambda()}
\item[Arguments:] none
\item[Value:]   a NumericalPoint. The parameter \textit{lambdaVector}.
\end{description}
\bigskip

\item \textit{getInputDimension}
\begin{description}
\item[Usage:] \textit{getInputDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the dimension $d$
\end{description}
\bigskip

\item \textit{getOutputDimension}
\begin{description}
\item[Usage:] \textit{getOutputDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the dimension $d$
\end{description}


\end{description}

\end{description}

% =====================================================
\newpage
% \index{Stochastic Process!ARMA!TrendFactory}
\index{TrendFactory}
\subsubsection{TrendFactory}


\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{TrendFactory(basisSequence, fittingAlgorithm)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{myBasisSequenceFactory}: a BasisSequenceFactory such as \textit{LAR}
\item \textit{myFittingAlgorithm}: a FittingAlgorithm such as \textit{KFold} or \textit{CorrectedLeaveOneOut}
\end{description}
\bigskip

\item[Value:] a TrendFactory
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}
\item \textit{build}
\begin{description}
\item[Usage:] \textit{build(field, basis)}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item  \textit{field}: a Field, the field on which the trend is built
\item  \textit{basis}: a NumericalMathFunctionCollection, on which the trend is decompos
\end{description}
\item[Value:]  a TrendTransform which contains the best dual combination of \textit{basis} in order to model the time series \textit{inTS}, using the regression strategy  \textit{myBasisSequenceFactory} and the fitting algorithm \textit{myFittingAlgorithm}.
\end{description}
\bigskip


\item \textit{getBasisSequenceFactory}
\begin{description}
\item[Usage:] \textit{getBasisSequenceFactory()}
\item[Arguments:] none
\item[Value:] a \textit{BasisSequenceFactory}, the one used the TrendFactory.
\end{description}
\bigskip

\item \textit{getFittingAlgorithm}
\begin{description}
\item[Usage:] \textit{getFittingAlgorithm()}
\item[Arguments:] none
\item[Value:] a FittingAlgorithm, the algorithm used by the TrendFactory.
\end{description}
\bigskip

\item \textit{setBasisSequenceFactory}
\begin{description}
\item[Usage:] \textit{setBasisSequenceFactory(basis)}
\item[Arguments:]  \textit{basis}: a BasisSequenceFactory
\item[Value:] None. We fix the basis sequence factory.
\end{description}
\bigskip

\item \textit{setFittingAlgorithm}
\begin{description}
\item[Usage:] \textit{setFittingAlgorithm(fittingAlgorithm)}
\item[Arguments:] fittingAlgorithm, a FittingAlgorithm that estimates the empirical error on each sub-basis
\item[Value:] None. We fix the fitting algorithm.
\end{description}
\bigskip


\end{description}

\end{description}


% =====================================================
\newpage
% \index{Stochastic Process!ARMA!TrendTransform}
\index{TrendTransform}
\subsubsection{TrendTransform}

This class inherits from \textit{TemporalFunction}.

\begin{description}

\item[Usage:] \textit{TrendTransform(f)}. Generally, it is obtained as the result of a \textit{TrendFactory.build(...)}. But it is possible to directly fix the evaluation function $f$ to be used.
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item $f$ : a NumericalMathFunction $f: \Rset^n \rightarrow \Rset^d$
\end{description}
\bigskip

\item[Value:] a TrendTransform, a function $f_{temp}: \cD\times \Rset^d \rightarrow \Rset^n \times \Rset^d$ that operates as follows:
\begin{align}\label{trendTempFunc}
f_{temp}(\vect{t}, \vect{x})=(\vect{t},  \vect{x} +  f(\vect{t}))
\end{align}


\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item $()$
\begin{description}
\item[Usage:] \textit{(myField)}
\item[Arguments:] \textit{myField}: a Field, which values are in $\Rset^d$, noted  $(\vect{x}_0, \dots, \vect{x}_{N-1})$, which mesh is composed of the vertices $(\vect{t}_0, \dots, \vect{t}_{N-1})$
\item[Value:]   a Field, which values are in $\Rset^d$, noted  $(\vect{y}_0, \dots, \vect{y}_{N-1})$ defined by:
\begin{equation}
\vect{y}_k = \vect{x}_k + f(\vect{t}_k)
\end{equation}
\end{description}
\bigskip

\item \textit{getFunction}
\begin{description}
\item[Usage:] \textit{getFunction()}
\item[Arguments:] none
\item[Value:]  a NumericalMathFunction, the function $f$
\end{description}
\bigskip

\item \textit{getInputDimension}
\begin{description}
\item[Usage:] \textit{getInputDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the input dimension of $f$: $n$.
\end{description}
\bigskip

\item \textit{getOutputDimension}
\begin{description}
\item[Usage:] \textit{getOutputDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the output dimension of the trend function: $d$
\end{description}
\bigskip

\item \textit{getInverse}
\begin{description}
\item[Usage:] \textit{getInverse()}
\item[Arguments:] none.
\item[Value:]   an InverseTrendTransform which contains the inverse trend function that can be used on the field $(\vect{y}_{0}, \dots,\vect{y}_{N-1})$ thanks to the operator  \emph{()}, in order to create the field $(\vect{x}_{0}, \dots,\vect{x}_{N-1})$ such that :
\begin{equation}
\vect{x}_k = \vect{y}_k - f(\vect{t}_k)
\end{equation}

\end{description}
\bigskip

\end{description}

\end{description}

% =====================================================
\newpage
% \index{Stochastic Process!ARMA!InverseTrendTransform}
\index{InverseTrendTransform}
\subsubsection{InverseTrendTransform}

This class inherits from \textit{TemporalFunction}.

\begin{description}

\item[Usage:] Generally, it is obtained as the result of a \textit{TrendTransform.getInverse()}. But it is possible to directly fix the evaluation function $f$ : \textit{InverseTrendTransform(f)}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item $f$ : a NumericalMathFunction $f: \Rset^n \rightarrow \Rset^d$
\end{description}
\bigskip

\item[Value:] an InverseTrendTransform, the inverse trend function $-f$.
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item $()$
\begin{description}
\item[Usage:] \textit{(myField)}
\item[Arguments:] \textit{myField}: a Field, which values are in $\Rset^d$, noted  $(\vect{y}_0, \dots, \vect{y}_{N-1})$, which mesh is composed of the vertices $(\vect{t}_0, \dots, \vect{t}_{N-1})$
\item[Value:]   a Field, which values are in $\Rset^d$, noted  $(\vect{x}_0, \dots, \vect{x}_{N-1})$ defined by:
\begin{equation}
\vect{x}_k = \vect{y}_k - f(\vect{t}_k)
\end{equation}
\end{description}
\bigskip


\item \textit{getFunction}
\begin{description}
\item[Usage:] \textit{getFunction()}
\item[Arguments:] none
\item[Value:]  a NumericalMathFunction, the function $-f$
\end{description}
\bigskip

\item \textit{getInputDimension}
\begin{description}
\item[Usage:] \textit{getInputDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the input dimension of $-f$: $n$.
\end{description}
\bigskip

\item \textit{getOutputDimension}
\begin{description}
\item[Usage:] \textit{getOutputDimension()}
\item[Arguments:] none
\item[Value:]   an integer, the output dimension of the trend function: $d$
\end{description}
\bigskip

\item \textit{getInverse}
\begin{description}
\item[Usage:] \textit{getInverse()}
\item[Arguments:] none.
\item[Value:]   an TrendTransform which contains the  trend function associated to $f$.
\end{description}
\bigskip



\end{description}

\end{description}

% =====================================================
\newpage     \subsubsection{DickeyFullerTest}

This class is a particular case.
Even if it helps to evaluate some hypothesis on time series, particularly non stationarity of this last one, it is used
through non static methods. This is mainly due to the strategy of test running.

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{DickeyFullerTest()}
\item \textit{DickeyFullerTest(timeSeries)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{timeSeries}:   a time series on which some hypothesis are checked
\end{description}

\item[Value:] DickeyFullerTest
\begin{description}
\item the DickeyFullerTest starts with checking if the time series is not empty.
\end{description}

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{testNoConstantModel}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{testNoConstantModel(level)}
\end{description}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{level}: a positive real value, the threshold p-value of the test ( = 1- first type risk), must be $< 1$, equal to 0.95 by default
\end{description}
\item[Value:]  a TestResult, the structure which contains the result of the test
\item[Details:] the methods is used to check whether a unit root is present in an $AR$ expression of the model
$Y_t = \rho Y_{t-1} + \epsilon_t$. Coefficients are estimated by a least square method. The test bases on the $\rho$ value.
\end{description}
\bigskip

\item \textit{testDriftModel}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{testDriftModel(level)}
\end{description}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{level}: a positive real value, the threshold p-value of the test ( = 1- first type risk), must be $< 1$, equal to 0.95 by default
\end{description}
\item[Value:]  a TestResult, the structure which contains the result of the test
\item[Details:] the methods is used to check whether a unit root is present in a model of form $Y_t = a + \rho Y_{t-1} + \epsilon_t$.
Coefficients are estimated by a least square method.
\end{description}
\bigskip

\item \textit{testTrendModel}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{testTrendModel(level)}
\end{description}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{level}: a positive real value, the threshold p-value of the test ( = 1- first type risk), must be $< 1$, equal to 0.95 by default
\end{description}
\item[Value:]  a TestResult, the structure which contains the result of the test
\item[Details:] the methods is used to check whether a unit root is present in a model of form $Y_t = a + b* t + \rho Y_{t-1} + \epsilon_t$.
\end{description}
\bigskip

\item \textit{runStrategy}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{runStrategy(level)}
\end{description}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{level}: a positive real value, the threshold p-value of the test ( = 1- first type risk), must be $< 1$, equal to 0.95 by default
\end{description}
\item[Value:]  a TestResult, the structure which contains the result of the test
\item[Details:] The method enables to run a strategy starting from the test of general model (trend model). Depending on the intermediate results, a path is followed
and thus indicates if the time series is stationary or not. In the last case, the strategy enables to get information about kind of non stationarity.
\end{description}
\bigskip

\item \textit{getVerbose}
\begin{description}
\item[Usage:] \textit{getVerbose()}
\item[Arguments:] none
\item[Value:] a boolean. Get information about level of verbosity of statistical test lanched, especially interesting when running the strategy.
\end{description}
\bigskip

\item \textit{setVerbose}
\begin{description}
\item[Usage:] \textit{setVerbose(bool)}
\item[Arguments:] a boolean
\item[Value:] Set verbosity to \textit{bool} value.
\end{description}
\bigskip

\item \textit{getName}
\begin{description}
\item[Usage:] \textit{getName()}
\item[Arguments:] none
\item[Value:] a string, the name of the DickeyFullerTest
\end{description}
\bigskip

\item \textit{setName}
\begin{description}
\item[Usage:] \textit{setName(name)}
\item[Arguments:] name : a string
\item[Value:] the class test is named \textit{name}
\end{description}
\bigskip

\end{description}

\end{description}


% =====================================================

\newpage
% \index{Stochastic Process!ARMA factory}
\subsection{ARMA factory}

The class enables to estimate the coefficients of an ARMA process using a realization or a sample of realizations

% \index{Stochastic Process!ARMA factory!ARMAFactory}
\index{ARMAFactory}
\subsubsection{ARMAFactory}

This class is the interface of \textit{ARMAFactoryImplementation}.\\

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{ARMAFactory(myARMAFactoryImplementation)}
\end{description}
\bigskip

\item[Arguments:] \textit{myARMAFactoryImplementation}: the implementation of an ARMA factory. For example, a Whittle factory.

\bigskip

\item[Value:] a ARMAFactory
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getName}
\begin{description}
\item[Usage:] \textit{getName()}
\item[Arguments:] none
\item[Value:] a string, the name of the ARMAFactory
\end{description}
\bigskip

\item \textit{setName}
\begin{description}
\item[Usage:] \textit{setName(name)}
\item[Arguments:] name : a string
\item[Value:] the ARMAFactory, named \textit{name}
\end{description}
\bigskip


\end{description}

\end{description}


\newpage
% \index{Stochastic Process!ARMA factory!WhittleFactoryState}
\index{WhittleFactoryState}
\subsubsection{WhittleFactoryState}

This class inherits from \textit{PersistenObject}.\\

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{WhittleFactoryState()}
\item \textit{WhittleFactoryState(p, theta, sigma2, criteria, timeGrid)}
\end{description}
\bigskip

\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item $p$ : integer. The order of the AR part of the estimate.
\item \textit{theta}: NumericalPoint. The coefficients of the scalar ARMA process, with the $p$ coefficients of the AR part first, followed by the $q$ coefficients of the MA part.
\item \textit{sigma2}: real. Estimate of the white noise variance.
\item \textit{criteria}: NumericalPoint. The information criteria associated with the estimate.
\item \textit{timeGrid}: TimeGrid. The time grid over which the estimated ARMA process is defined.
m estimate
\end{description}
\bigskip

\item[Value:] a WhittleFactoryState
\rule{0pt}{1em}
\begin{description}
\item in the second usage, the object stores the minimal sufficient information on a particular estimation step of the WhittleFactory class, from which all the relevant other information can be recovered.
\end{description}
\bigskip


\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getARCoefficients}
\begin{description}
\item[Usage:] \textit{getARCoefficients()}
\item[Arguments:] None
\item[Value:] ARMACoefficient. the AR coefficients of the estimate.
\end{description}
\bigskip

\item \textit{getARMA}
\begin{description}
\item[Usage:] \textit{getARMA()}
\item[Arguments:] None
\item[Value:] ARMA. The ARMA process associated with the estimated parameters.
\end{description}
\bigskip

\item \textit{getMACoefficients}
\begin{description}
\item[Usage:] \textit{getMACoefficients()}
\item[Arguments:] None
\item[Value:] ARMACoefficient. the MA coefficients of the estimate.
\end{description}
\bigskip

\item \textit{getInformationCriteria}
\begin{description}
\item[Usage:] \textit{getInformationCriteria()}
\item[Arguments:] None
\item[Value:] NumericalPoint. The information criteria associated with the estimate. There are 3 information criterion that are computed: the corrected AIC, the AIC and the BIC, stored in this order.
\end{description}
\bigskip

\item \textit{getP}
\begin{description}
\item[Usage:] \textit{getP()}
\item[Arguments:] None
\item[Value:] integer. The AR order of the estimate.
\end{description}
\bigskip

\item \textit{getQ}
\begin{description}
\item[Usage:] \textit{getQ()}
\item[Arguments:] None
\item[Value:] integer. The MA order of the estimate.
\end{description}
\bigskip

\item \textit{getSigma2}
\begin{description}
\item[Usage:] \textit{getSigma2()}
\item[Arguments:] None
\item[Value:] real. The estimate of the white noice variance.
\end{description}
\bigskip

\item \textit{getTheta}
\begin{description}
\item[Usage:] \textit{getTheta()}
\item[Arguments:] None
\item[Value:] NumericalPoint. The ARMA coefficients estimate as manipulated during the optimization step.
\end{description}
\bigskip

\item \textit{getTimeGrid}
\begin{description}
\item[Usage:] \textit{getTimeGrid()}
\item[Arguments:] None
\item[Value:] TimeGrid. The time grid over which the ARMA precess is defined, as given by the data.
\end{description}
\bigskip

\item \textit{getWhiteNoise}
\begin{description}
\item[Usage:] \textit{getWhiteNoise()}
\item[Arguments:] None
\item[Value:] WhiteNoise. The scalar white noise process associated with the ARMA process. It is build using a Normal distribution with zero mean and with the estimated variance.
\end{description}
\bigskip


\end{description}

\end{description}


% =====================================================

\newpage
% \index{Stochastic Process!ARMA factory!WhittleFactory}
\index{WhittleFactory}
\subsubsection{WhittleFactory}

This class inherits from \textit{ARMAFactoryImplementation}.\\

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{WhittleFactory()}
\item \textit{WhittleFactory(p, q, invertible)}
\item \textit{WhittleFactory(pIndices, qIndices, invertible)}
\end{description}
\bigskip

\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item $p$ : integer. The order of the AR part to be tested.
\item $q$ : integer. The order of the MA part to be tested.
\item \textit{invertible}: boolean. Flag to restrict the estimation to invertible ARMA processes.
\item \textit{pIndices}: Indices. The possible orders of the AR part to be tested.
\item \textit{qIndices}: Indices. The possible orders of the MA part to be tested.
m estimate
\end{description}
\bigskip

\item[Value:] a WhittleFactory
\rule{0pt}{1em}
\begin{description}
\item in the first usage, the Whittle factory is such that a normal white noise will be identified.
\item in the second usage, we fix the order of the ARMA (AR size and MA size) process that will be identified, with a control on its invertibility,
\item in the third usage, we fix a range of orders for the AR and the MA parts. All the possible combinations will be tested.
\end{description}
\bigskip


\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{build}
\begin{description}
\item[Usage:]
\begin{description}
\item \textit{build(series)}
\item \textit{build(series, criteria)}
\item \textit{build(sample)}
\item \textit{build(sample, criteria)}
\end{description}
\item[Arguments:]
\begin{description}
\item \textit{series}: a TimeSeries
\item \textit{criteria}: a NumericalPoint
\item \textit{sample}: a ProcessSample
\end{description}
\item[Value:] an ARMA process, the model that matches the best the given time series or process sample. The comparison is made using the spectral density built using the given data and theoretical spectral density of the ARMA process.

If given, the \textit{criteria} vector is filled by three scalar values: the corrected AIC criterion, the AIC criterion and the BIC criterion. The best ARMA process is selected according to the corrected AIC criterion.
\end{description}
\bigskip

\item \textit{getSpectralModelFactory}
\begin{description}
\item[Usage:] \textit{getSpectralModelFactory()}
\item[Arguments:] None.
\item[Value:] a SpectralModelFactory object. Returns the spectral factory used to estimate the spectral density based on the data during the estimation step.
\end{description}
\bigskip

\item \textit{setSpectralModelFactory}
\begin{description}
\item[Usage:] \textit{setSpectralModelFactory(spectralFactory)}
\item[Arguments:] a SpectralModelFactory.
\item[Value:] None. Set the spectral factory used to estimate the spectral density based on the data during the estimation step.
\end{description}
\bigskip

\item \textit{disableHistory}
\begin{description}
\item[Usage:] \textit{disableHistory()}
\item[Arguments:] None.
\item[Value:] None. Desactivate the history mechanism, it means the trace of all the tested models and their associated information criteria.
\end{description}
\bigskip

\item \textit{enableHistory}
\begin{description}
\item[Usage:] \textit{enableHistory()}
\item[Arguments:] None.
\item[Value:] None. Activate the history mechanism, it means the trace of all the tested models and their associated information criteria.
\end{description}
\bigskip

\item \textit{isHistoryEnabled}
\begin{description}
\item[Usage:] \textit{isHistoryEnabled()}
\item[Arguments:] None.
\item[Value:] a logical value. True if the history mechanism is activated. It is activated by default.
\end{description}
\bigskip

\item \textit{clearHistory}
\begin{description}
\item[Usage:] \textit{clearHistory()}
\item[Arguments:] None.
\item[Value:] None. Clear the history of the factory.
\end{description}
\bigskip

\item \textit{getHistory}
\begin{description}
\item[Usage:] \textit{getHistory()}
\item[Arguments:] None.
\item[Value:] a collection of WhittleFactoryState objects. Returns the collection of all the states that have been built during the estimation phase.
\end{description}
\bigskip

\item \textit{setVerbose}
\begin{description}
\item[Usage:] \textit{setVerbose(verbose)}
\item[Arguments:] a logical value.
\item[Value:] None. Activate the verbose mode of the factory during both the exploration of the possible models and the optimization steps.
\end{description}
\bigskip

\item \textit{getVerbose}
\begin{description}
\item[Usage:] \textit{getVerbose()}
\item[Arguments:] None.
\item[Value:] a logical value telling if the verbose mode has been activated.
\end{description}
\bigskip

\item \textit{setStartingPoints}
\begin{description}
\item[Usage:] \textit{setStartingPoints(points)}
\item[Arguments:] a collection of NumericalPoints.
\item[Value:] None. Set the starting points in the $(p, q)$ parameters space during the optimization step, for each pair of orders that will be tested.
\end{description}
\bigskip

\item \textit{getStartingPoints}
\begin{description}
\item[Usage:] \textit{getStartingPoints()}
\item[Arguments:] None.
\item[Value:] a collection of NumericalPoints. Returns the starting points in the $(p, q)$ parameters space during the optimization step, for each pair of orders that will be tested.
\end{description}
\bigskip

\end{description}

\end{description}

% =======================================================================================================================================
\newpage
\subsubsection{ARMALikelihoodFactory}

This class inherits from \textit{ARMAFactoryImplementation}.\\

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{ARMALikelihoodFactory()}
\item \textit{ARMALikelihoodFactory(p, q, d)}
\item \textit{ARMALikelihoodFactory(P, Q, d)}
\end{description}
\bigskip

\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{p}: integer, the order of the AR part
\item \textit{P}: indices, the potential orders of the AR part
\item \textit{q}: integer, the order of the MA part
\item \textit{Q}: indices, the potential orders of the MA part
\item \textit{d}: integer, the dimension of the factory
\end{description}
\bigskip

\item[Value:] a ARMALikelihoodFactory
\rule{0pt}{1em}
\begin{description}
\item We fix the dimension of the underlying ARMA model and at least a non null couple of integer p (respectively q), order of the AR (respectively MA) parts
\end{description}
\bigskip


\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{build}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{build(ts)}
\item \textit{build(ps)}
\end{description}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{ts}: a TimeSeries
\item \textit{ps}: a ProcessSample
\end{description}
\item[Value:]   a \textit{ARMA}, the ARMA modelisation of the underlying process
\end{description}
\bigskip

\item \textit{getInitialARCoefficients}
\begin{description}
\item[Usage:] \textit{getInitialARCoefficients()}
\item[Arguments:] none
\item[Value:]  object of type \textit{ARMACoefficients}, the initial AR coefficients used for the optimization algorithm
\end{description}

\item \textit{getInitialMACoefficients}
\begin{description}
\item[Usage:] \textit{getInitialMACoefficients()}
\item[Arguments:] none
\item[Value:]  object of type \textit{ARMACoefficients}, the initial MA coefficients used for the optimization algorithm
\end{description}

\item \textit{getInitialCovarianceMatrix}
\begin{description}
\item[Usage:] \textit{getInitialCovarianceMatrix()}
\item[Arguments:] none
\item[Value:]  a \textit{CovarianceMatrix}, the covariance matrix associated to the estimated white noise
\end{description}


\item \textit{setInitialARCoefficients}
\begin{description}
\item[Usage:] \textit{setInitialARCoefficients(ar)}
\item[Arguments:] \textit{ARMACoefficients}
\item[Value:]  none , set the initial AR coefficients for the optimization algorithm
\end{description}

\item \textit{setInitialMACoefficients}
\begin{description}
\item[Usage:] \textit{setInitialMACoefficients(ma)}
\item[Arguments:] \textit{ARMACoefficients}
\item[Value:]  none, set the initial MA coefficients for the optimization algorithm
\end{description}

\item \textit{setInitialCovarianceMatrix}
\begin{description}
\item[Usage:] \textit{setInitialCovarianceMatrix(mat)}
\item[Arguments:]  \textit{CovarianceMatrix}
\item[Value:]  none, set initial covariance matrix associated to the estimation white noise
\end{description}

\item \textit{setInitialConditions}
\begin{description}
\item[Usage:] \textit{setInitialConditions(ar, ma, mat)}
\item[Arguments:]
\begin{itemize}
\item ar : \textit{ARMACoefficients}
\item ma :  \textit{ARMACoefficients}
\item mat : a \textit{CovarianceMatrix}
\end{itemize}
\item[Value:]  none, set initial AR coefficients, MA coefficients and covariance matrix for the optimization algorithm
\end{description}

\end{description}

\end{description}

% =====================================================


\newpage
% \index{Stochastic Process!RandomWalk}
\index{RandomWalk}
\subsection{RandomWalk}

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{RandomWalk(origin, distribution)}
\item \textit{RandomWalk(origin, distribution, timeGrid)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{origin}: a NumericalPoint, the starting point of the random walk.
\item \textit{distribution}: a Distribution, the distribution used for the steps of the random walk.
\item \textit{timeGrid}: a RegularGrid, the time grid over which the realizations are observed
\end{description}
\bigskip

\item[Value:] a RandomWalk process
\rule{0pt}{1em}
\begin{description}
\item in the first usage, we fix the origin and distribution of the process. They must have a common dimension, which is also the dimension of the process. The time grid is by default reduced to one time stamp $t=0$.
\item in the second usage, we fix also the time grid of the observations.
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getOrigin}
\begin{description}
\item[Usage:] \textit{getOrigine()}
\item[Arguments:] none
\item[Value:] a NumericalPoint, the starting point of the random walk.
\end{description}
\bigskip

\item \textit{setOrigin}
\begin{description}
\item[Usage:] \textit{setOrigin(origin)}
\item[Arguments:] \textit{origin}, a NumericalPoint
\item[Value:] none. Fix the starting point of the random walk.
\end{description}
\bigskip

\end{description}

\begin{description}

\item \textit{getDistribution}
\begin{description}
\item[Usage:] \textit{getDistribution()}
\item[Arguments:] none
\item[Value:] a Distribution, the distribution used to generate the steps of the random walk.
\end{description}
\bigskip

\item \textit{setDistribution}
\begin{description}
\item[Usage:] \textit{setDistribution(distribution)}
\item[Arguments:] \textit{distribution}, a Distribution
\item[Value:] none. Fix the distribution for the steps of the random walk.
\end{description}
\bigskip

\end{description}

\end{description}

% =====================================================


\newpage
% \index{Stochastic Process!WhiteNoise}
\index{WhiteNoise}

\subsection{WhiteNoise}



A second order white noise $\varepsilon: \Omega \times \cD \rightarrow \Rset^d$  is a stochastic process of dimension $d$ such that the covariance function $C(\vect{s},\vect{t})=\delta(\vect{t}-\vect{s})C(\vect{s},\vect{s})$ where $C(\vect{s},\vect{s})$  is the covariance matrix of the process at vertex $\vect{s}$ and $\delta$ the Kroenecker function.\\

A process $\varepsilon$ is a white noise if  all finite family of locations  $(\vect{t}_i)_{i=1, \dots, n} \in \cD$, $(\varepsilon_{\vect{t}_i})_{i=1, \dots, n}$ is independent and identically distributed.\\

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{WhiteNoise(distribution)}
\item \textit{WhiteNoise(distribution, mesh)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{distribution}: a Distribution, the distribution used for the realization of the white noise. Care! A white noise has a zero mean and finite standard deviation distribution!
\item \textit{mesh}: a Mesh in $\Rset^n $ over which the process is discretized.
\end{description}
\bigskip

\item[Value:] a WhiteNoise process with zero mean and finite standard deviation.
\rule{0pt}{1em}
\begin{description}
\item in the first usage, we fix the distribution of dimension $d$. The Mesh is reduced to one point in $\Rset$ ($n=1$) which coordinate is equal to 0.
\item in the second usage, we fix the common distribution of dimension $d$ and we give the mesh in $\Rset^n$ over which the process is discretized.
\end{description}
\bigskip

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getDistribution}
\begin{description}
\item[Usage:] \textit{getDistribution()}
\item[Arguments:] none
\item[Value:] a Distribution, the $d$-dimensional distribution used to generate random vectors at each vertex of the mesh.
\end{description}
\bigskip

\item \textit{getMarginal}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{getMarginal(N)}
\item \textit{getMarginal(indices)}
\end{description}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item $N$ : an integer, designing the marginal to be extracted
\item \textit{indices}: a \textit{Indices} which regroups all the marginals to be extracted.
\end{description}
\item[Value:] a WhiteNoise, of dimension 1 or \textit{indices.getSize()}, formed with the extracted marginals of the initial white noise.
\end{description}
\bigskip

\item \textit{setDistribution}
\begin{description}
\item[Usage:] \textit{setDistribution(distribution)}
\item[Arguments:] \textit{distribution}, a Distribution
\item[Value:] none. Fix the $d$-dimensional distribution of the random vectors defined at each vertex of the mesh.
\end{description}
\bigskip

\end{description}

\end{description}


% =====================================================


\newpage
% \index{Stochastic Process!FunctionalBasisProcess}
\index{FunctionalBasisProcess}
\subsection{FunctionalBasisProcess}

Let $X: \Omega \times \cD \rightarrow \Rset^d$  be a multivariate stochastic process of dimension $d$ where $\cD \in \Rset^n$. A functional basis process is defined as a linear combination of $K$ deterministic functions $(\phi_i)_{i=1,\dots,K}: \Rset^n \rightarrow \Rset^d$:
\begin{align*}
X(\omega,\vect{t})=\sum_{i=1}^KA_i(\omega)\phi_i(\vect{t})
\end{align*}
where $\vect{A}=(A_1,\dots, A_K)$ is a random vector of dimension $K$.\\




\begin{description}

\item[Usage:] \textit{FunctionalBasisProcess(distribution, basis)}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{distribution}: a Distribution, the distribution of the random coefficients in the decomposition over the basis.
\item \textit{basis}: a Basis, a collection of functions from $\Rset$ into $\Rset^n$, where $n$ is the dimension of the process.
\item \textit{myMesh}: a Mesh, the mesh associated to the process.
\end{description}
\bigskip

\item[Value:] a FunctionalBasis process built as follows. The joint distribution of the coefficients $\alpha_i(\omega)$ is \textit{distribution} and the basis $\phi_i$ is \textit{basis}.

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getBasis}
\begin{description}
\item[Usage:] \textit{getBasis()}
\item[Arguments:] none
\item[Value:] a Basis, the functional basis over which the process is decomposed.
\end{description}
\bigskip

\item \textit{setBasis}
\begin{description}
\item[Usage:] \textit{setBasis(basis)}
\item[Arguments:] \textit{basis}, a Basis
\item[Value:] none. Set the functional basis over which the process is decomposed.
\end{description}
\bigskip

\item \textit{getDistribution}
\begin{description}
\item[Usage:] \textit{getDistribution()}
\item[Arguments:] none
\item[Value:] a Distribution, the distribution of the random coefficients of the process over the basis.
\end{description}
\bigskip

\item \textit{setDistribution}
\begin{description}
\item[Usage:] \textit{setDistribution(distribution)}
\item[Arguments:] \textit{distribution}, a Distribution
\item[Value:] none. Set the distribution of the random coefficients of the process over the basis.
\end{description}
\bigskip

\end{description}

\end{description}

% =====================================================

\newpage
% \index{Stochastic Process!Composite process}
\subsection{Composite process}

This class inherits from \textit{Process}. \\
The objective is to build a stochastic process upon a function and a process such as \textit{ARMA} or \textit{SpectralNormalProcess} for example.

% \index{Stochastic Process!Composite process!CompositeProcess}
\index{CompositeProcess}
\begin{description}

\item[Usage:]  \textit{CompositeProcess(fdyn, X)}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{function}: a DynamicalFunction,  $f_{dyn}:\cD \times \Rset^d \rightarrow \cD' \times \Rset^q$ where $\cD \in \Rset^n$ and  $\cD' \in \Rset^p$, defined by:
\begin{align}\label{dynFct}
f_{dyn}(\vect{t}, \vect{x}) = (t'(\vect{t}), v'(\vect{t}, \vect{x}))
\end{align}
with $t': \cD \rightarrow \cD'$ and $v': \cD \times \Rset^d \rightarrow \Rset^q$.
\item $X$ : a Process. The input process $X: \Omega \times \cD \rightarrow \Rset^d$ where $\cD \in \Rset^n$.
\end{description}
\bigskip

\item[Value:] a CompositeProcess process defined by $Y = fdyn(X)$ defined by $Y: \Omega \times \cD' \rightarrow \Rset^q$ where the mesh $\cD' \in \Rset^p$  is discretized according to the $\cM'$.

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getFunction}
\begin{description}
\item[Usage:] \textit{getFunction()}
\item[Arguments:] none
\item[Value:] a DynamicalFunction, the function used for the evaluation.
\end{description}
\bigskip

\item \textit{getAntecedent}
\begin{description}
\item[Usage:] \textit{getAntecedent()}
\item[Arguments:] none
\item[Value:] a Process, the proces $X$ such as the current proces is obtained by $Y= fdyn(X)$.
\end{description}


\end{description}
\end{description}
