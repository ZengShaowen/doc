% Copyright (C) 2005-2015 Airbus - EDF - IMACS - Phimeca
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts.  A copy of the license is included in the section entitled "GNU
% Free Documentation License".
\newpage
\extanchor{integration}
\section{Integration}

%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\subsection{Gauss-Kronrod algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\index{GaussKronrodRule}
\subsubsection{GaussKronrodRule}


The Gauss-Kronrod rules {\itshape GmKp} with  $m=2n+1$ and $p=2m+1$ enable to build two approximations of the definite integral $\int_{-1}^1 f(t)\, dt$:
\begin{align}\label{GKapprox}
  \int_{-1}^1 f(t)\, dt \simeq & \omega_0f(0) + \sum_{k=1}^n \omega_k (f(\xi_k)+f(-\xi_k))\\
  \simeq & w_0f(0) + \sum_{k=1}^{m} w_k (f(\zeta_k)+f(-\zeta_k))
\end{align}
where $m=2n+1$. We have $\xi_k>0$,  $\zeta_k>0$, $\zeta_{2j}=\xi_j$, $\omega_k>0$ and $w_k>0$.


\begin{description}
\item[Usage:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{GaussKronrodRule(myGaussKronrodPair)}
  \end{description}

\item[Arguments:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{codeRule}: a GaussKronrodPair, that encodes the selected rule: it can takes the following values: GaussKronrodRule.G3K7, GaussKronrodRule.G7K15, GaussKronrodRule.G11K23, GaussKronrodRule.G15K31, GaussKronrodRule.G25K51.
  \end{description}

\item[Details:] The rule {\itshape GaussKronrodRule.GmKp} combines a $m$-point Gauss rule and a $p$-point Kronrod rule (re-using the $m$ nodes of the Gauss method). The nodes are defined on $[-1, 1]$ and always contain the node 0 when $m$ is odd. OpenTURNS takes $m$ such that $m=2n+1$.\\

\item[Some methods:]  \rule{0pt}{1em}


  \begin{description}


  \item \textit{getOrder}
    \begin{description}
    \item[Usage:] \textit{getOrder()}
    \item[Arguments:] none
    \item[Value:]  an integer, the number $m$.
    \end{description}
    \bigskip


  \item \textit{getOtherGaussWeights}
    \begin{description}
    \item[Usage:] \textit{getOtherGaussWeights()}
    \item[Arguments:] none
    \item[Value:]  a NumericalPoint that gives the weights $(\omega_k)_{1 \leq k \leq n}$.
    \end{description}
    \bigskip

  \item \textit{getOtherKronrodNodes}
    \begin{description}
    \item[Usage:] \textit{getOtherKronrodNodes()}
    \item[Arguments:] none
    \item[Value:]  a NumericalPoint, that gives the positive nodes $(\zeta_k)_{1 \leq k \leq m}$ of the Kronrod rule. It contains the positive Gauss nodes as we have $\zeta_{2j}=\xi_j$.
    \end{description}
    \bigskip

  \item \textit{getOtherKronrodWeights}
    \begin{description}
    \item[Usage:] \textit{getOtherKronrodWeights()}
    \item[Arguments:] none
    \item[Value:]  a NumericalPoint, that gives the positive nodes $(w_k)_{1 \leq k \leq m}$ of the Kronrod rule.
    \end{description}
    \bigskip

  \item \textit{getZeroGaussWeight}
    \begin{description}
    \item[Usage:] \textit{getZeroGaussWeight()}
    \item[Arguments:] none
    \item[Value:]  a scalar, that is $\omega_0$.
    \end{description}
    \bigskip

  \item \textit{getZeroKronrodWeight}
    \begin{description}
    \item[Usage:] \textit{getZeroKronrodWeight()}
    \item[Arguments:] none
    \item[Value:]  a scalar, that is $w_0$.
    \end{description}

  \end{description}

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\index{GaussKronrod}
\subsubsection{GaussKronrod}

The Gauss-Kronrod algorithm enables to approximate the definite integral :
\begin{align}\label{integral}
  \int_{a}^b f(t)\, dt
\end{align}
using both approximations : Gauss and Kronrod ones.

\begin{description}

\item[Usage:]  \textit{GaussKronrod(maximumSubIntervals, maximumError, GKRule)}

\item[Arguments:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{maximumSubIntervals}: an integer, the maximum number of subdivisions of the intervall autorized.
  \item \textit{maximumError}: a scalar whcih controls the difference of both approximations (Gauss and Kronrod ones).
  \item \textit{GKRule}: a GaussKronrodRule that defines the rules that will ba applied
  \end{description}

\item[Details:] The Gauss-Kronrod algorithm evaluates the integrale (\ref{integral}) using the Gauss and the Konrod approximations (\ref{GKapprox}. If the difference between both approximations is greater that {\itshape maximumError}, then the interval $[a,b]$ is subdivided into 2 subintervals with the same length. The Gauss-Kronrod algorihtm is then applied on both subintervals with the sames rules. The algorithm is iterative until the  difference between both approximations is less that {\itshape maximumError}. In that case, the integrale on the subinterval is approximated by the Kronrod sum. The subdivision process is limited by {\itshape maximumSubIntervals} that imposes the maximum number of subintervals.\\
  The final integral is the sum of the integrals evaluated on the subintervals.

\item[Some methods:]  \rule{0pt}{1em}


  \begin{description}


  \item \textit{getMaximumError}
    \begin{description}
    \item[Usage:] \textit{getMaximumError()}
    \item[Arguments:] none
    \item[Value:]  a positive scalar that controls the precision of the approximation.
    \end{description}
    \bigskip


  \item \textit{getMaximumSubIntervals}
    \begin{description}
    \item[Usage:] \textit{getMaximumSubIntervals()}
    \item[Arguments:] none
    \item[Value:]  an integer, the maximum number of subintervals.
    \end{description}
    \bigskip


  \item \textit{getRule}
    \begin{description}
    \item[Usage:] \textit{getRule()}
    \item[Arguments:] none
    \item[Value:]  a GaussKronrodRule, the rules of the algorithm.
    \end{description}
    \bigskip


  \item \textit{integrate}
    \begin{description}
    \item[Usage:] \rule{0pt}{1em}
      \begin{description}
      \item \textit{integrate(function, interval)}
      \item \textit{integrate(function, interval, error)}
      \item \textit{integrate(function, a, b, error, ai, bi, fi, ei)}
      \end{description}
    \item[Arguments:]\rule{0pt}{1em}
      \begin{description}
      \item \textit{function}: a NumericalMathFunction, the function $f$.
      \item \textit{interval}: a Interval, the interval $[a,b]$.
      \item \textit{error}: a NumericalPoint of dimension 1, the error estimation of the approximation given by the algorithm.
      \item $a,b$: two scalars, the bounds of the interval $[a,b]$.
      \item $ai, bi, fi, ei$: some NumericalPoint, where $ai$ regroups the lower bounds of the subintervals, and $bi$ the corresponding upper bounds; $fi$ regroups the estimation of $\int_{ai}^{bi} f(t)\, dt$ and $ei$ the associated error estimation given by the algorithm .
      \end{description}
    \item[Value:]  a scalar, the approximation of (\ref{integral}).
    \end{description}

  \end{description}

\end{description}
