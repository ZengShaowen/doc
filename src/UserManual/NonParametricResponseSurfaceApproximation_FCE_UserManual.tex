% Copyright (C) 2005-2015 Airbus - EDF - IMACS - Phimeca
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts.  A copy of the license is included in the section entitled "GNU
% Free Documentation License".


\newpage

\extanchor{funcChaos}
\section{Response Surface : Functional Chaos Expansion}
% \index{Response Surface : Functional Chaos Expansion}
The polynomial chaos expansion enables to approximate the output random variable of interest :
\begin{equation}\label{Model}
\vect{Y} = g(\vect{X}) \in \Rset^p
\end{equation}
where  $g : \Rset^n \longrightarrow \Rset^p $ is the model, $\vect{X}$ is the input random vector of dimension $n$ by the  response surface :
\begin{equation}\label{metaModel}
\tilde{\vect{Y}} = \sum_{k \in K} \vect{\alpha}_k \Psi_k \circ T(\vect{X})
\end{equation}
with :
\begin{equation}\label{coeff}
\vect{\alpha}_k \in \Rset^p
\end{equation}
$T$ is an isoprobabilistic transformation which maps the multivariate distribution of $\vect{X}$ into the multivariate distribution,
\begin{equation}\label{mudist}
\mu = \prod_{i=1}^n \mu_i
\end{equation}
and  $(\Psi_k)_{k \in \Nset}$ a multivariate polynomial basis of $\cL^2_{\mu}(\Rset^n,\Rset)$ which is orthonornal according to the distribution $\mu$. $K$ is a finite subset of $\Nset$. \\
The distribution $\mu$ is supposed to have an independent copula and $Y$ be of finite second moment.

% \index{Response Surface : Functional Chaos Expansion!FunctionalChaosAlgorithm}
\index{FunctionalChaosAlgorithm}
\subsection{FunctionalChaosAlgorithm}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{FunctionalChaosAlgorithm()}
\item \textit{FunctionalChaosAlgorithm(model, distribution, adaptiveStrategy)}
\item \textit{FunctionalChaosAlgorithm(model, distribution, adaptiveStrategy, projectionStrategy)}
\item \textit{FunctionalChaosAlgorithm(inputSample, weights, outputSample, distribution, adaptiveStrategy, projectionStrategy)}
\end{description}
\bigskip

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{model}: a NumericalMathFunction, the physical model $g$ defined in (\ref{Model}) that behaves as a NumericalMathFunction.
\item \textit{distribution}: a Distribution, the joint probability density function of the physical input vector
\item \textit{inputSample, outputSample}: NumericalSample, the input and output samples of a model evaluated apart.
\item \textit{weight}: NumericalPoint, the weights of each point of the \textit{inputSample}.
\item \textit{adaptiveStrategy}: an AdaptiveStrategy, the strategy of selection of the basis (see AdaptiveStrategy above)
\item \textit{projectionStrategy}: a ProjectionStrategy, that defines the strategy of projection of the empirical model results in the selected orthonormal basis (see ProjectionStrategy).
\end{description}

\item[Value:] a FunctionalChaosAlgorithm. In the second usage, the projection strategy considered is the LeastSquaresStrategy. In the last usage, the model is not required and replaced by some given input sample and output sample. The weights $\omega_i$ are determined such that $\sum_{i\in I} \omega_i \delta_{\vect{X}_i} \simeq p_{\vect{X}}$, where $p_{\vect{X}}$ is the distribution of the input random vector $\vect{X}$. When not specified, the  \textit{weight} are all equal to
\begin{align*}
\omega_i = \displaystyle \frac{1}{card I}
\end{align*}

\item[Some methods :]  \rule{0pt}{1em}
\begin{description}

\item \textit{getMaximumResidual}
\begin{description}
\item[Usage:] \textit{getMaximumResidual()}
\item[Arguments:] none
\item[Value:] a NumericalScalar, the residual value needed in the projection strategy. By default, its value is 0.
\end{description}
\bigskip



\item \textit{getProjectionStrategy}
\begin{description}
\item[Usage:] \textit{getProjectionStrategy()}
\item[Arguments:] none
\item[Value:] a ProjectionStrategy, the projection strategy of the FunctionalChaosAlgorithm.
\end{description}
\bigskip


\item \textit{run}
\begin{description}
\item[Usage:] \textit{run()}
\item[Arguments:] none
\item[Value:] execute the procedure of determination of coefficients using the projection strategy selected with respect to the AdaptiveStrategy selected. It provides the results as an object of type FunctionalChaosResult.
\end{description}
\bigskip
\item \textit{getResult}
\begin{description}
\item[Usage:] \textit{getResult()}
\item[Arguments:] none
\item[Value:] a FunctionalChaosResult, which contains all results of the execution.
\end{description}

\end{description}

\end{description}



The method \textit{getMaximumResidual} has its associated \textit{setMaximumResidual}.



% -=============================================================

% \index{Response Surface : Functional Chaos Expansion!FunctionalChaosResult}
\index{FunctionalChaosResult}
\subsection{FunctionalChaosResult}


\begin{description}

\item[Usage:]  structure created by the method run() of a  FunctionalChaosAlgorithm and obtained thanks to the method \textit{getResult()}.


\item[Some methods :]  \rule{0pt}{1em}
\begin{description}

\item \textit{getCoefficients}
\begin{description}
\item[Usage:] \textit{getCoefficients()}
\item[Arguments:] none
\item[Value:] a NumericalSample, the collection of coefficients of the functional chaos $(\vect{\alpha}_k)_{k\in K}$
\end{description}
\bigskip

\item \textit{getComposedMetaModel}
\begin{description}
\item[Usage:] \textit{getComposedMetaModel()}
\item[Arguments:] none
\item[Value:] a NumericalMathFunction, $\hat{h} =\sum_{k \in K} \vect{\alpha}_k \Psi_k$.
\end{description}
\bigskip


\item \textit{getComposedModel}
\begin{description}
\item[Usage:] \textit{getComposedModel()}
\item[Arguments:] none
\item[Value:] a NumericalMathFunction, $h$ which is the composition of the physical model $g$ and the inverse iso-probabilistic transformation: $h : \vect{Z} \longrightarrow \vect{Y} = g \circ T^{-1}(\vect{Z})$. We have  $\displaystyle h =  \sum_{k \in \Nset} \vect{\alpha}_k \Psi_k$.
\end{description}
\bigskip

\item \textit{getDistribution}
\begin{description}
\item[Usage:] \textit{getDistribution()}
\item[Arguments:] none
\item[Value:] a Distribution, the joint distribution of the physical input vector
\end{description}
\bigskip

\item \textit{getIndices}
\begin{description}
\item[Usage:] \textit{getIndices()}
\item[Arguments:] none
\item[Value:] an Indices, the collection of integers that represent the indices of the final basis
\end{description}
\bigskip


\item \textit{getInverseTransformation}
\begin{description}
\item[Usage:] \textit{getInverseTransformation()}
\item[Arguments:] none
\item[Value:] a NumericalMathFunction, the inverse iso-probabilistic transformation $T^{-1}$ that transforms the data distributed according to the measure imposed by the selected orthonormal basis into the input data: $T^{-1}: \Rset^n \longrightarrow\Rset^n $, $T^{-1}(\vect{Z}) = \vect{X}$
\end{description}
\bigskip

\item \textit{getMeasure}
\begin{description}
\item[Usage:] \textit{getMeasure()}
\item[Arguments:] none
\item[Value:] a Distribution, the measure $\mu$
\end{description}
\bigskip

\item \textit{getMetaModel}
\begin{description}
\item[Usage:] \textit{getMetaModel()}
\item[Arguments:] none
\item[Value:] a NumericalMathFunction,  $\hat{g}  = \hat{h} \circ T$.
\end{description}
\bigskip

\item \textit{getModel}
\begin{description}
\item[Usage:] \textit{getModel()}
\item[Arguments:] none
\item[Value:] a NumericalMathFunction, the physical model $g$ defined in (\ref{Model}).
\end{description}
\bigskip


\item \textit{getReducedBasis}
\begin{description}
\item[Usage:] \textit{getReducedBasis()}
\item[Arguments:] none
\item[Value:] a NumericalMathFunctionCollection, a collection of NumericalMathFunction that correspond to the basis of the functional chaos $(\Psi_k)_{k\in K}$
\end{description}
\bigskip


\item \textit{getResiduals}
\begin{description}
\item[Usage:] \textit{getResiduals()}
\item[Arguments:] none
\item[Value:] a NumericalPoint, the residual values defined as follows for each output of the model:
    $\displaystyle \frac{\sqrt{\sum_{i=1}^N (y_i - \hat{y_i})^2}}{N}$
    with $y_i$ the $N$ model's values and $\hat{y_i}$ the metamodel's values
\end{description}
\bigskip


\item \textit{getRelativeErrors}
\begin{description}
\item[Usage:] \textit{getRelativeErrors()}
\item[Arguments:] none
\item[Value:] a NumericalPoint, the relative errors  defined as follows for each output of the model:
    $\displaystyle \frac{\sum_{i=1}^N (y_i - \hat{y_i})^2}{N \Var{\vect{Y}}}$
    with $\vect{Y}$ the vector of the $N$ model's values
    $y_i$ and $\hat{y_i}$ the metamodel's values
\end{description}
\bigskip


\item \textit{getTransformation}
\begin{description}
\item[Usage:] \textit{getTransformation()}
\item[Arguments:] none
\item[Value:] a NumericalMathFunction, the iso-probabilistic transformation $T$ that transforms the input data into a data following the measure imposed by the selected orthonormal basis: $T : \Rset^n \longrightarrow \Rset^n $, $T(\vect{X}) = \vect{Z}$
\end{description}



\end{description}

\end{description}



% -=============================================================
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis}
\subsection{Construction of the multivariate orthogonal basis}


% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!OrthogonalBasis}
\index{OrthogonalBasis}
\subsubsection{OrthogonalBasis}

\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{OrthogonalBasis()}
\item \textit{OrthogonalBasis(orthogonalProductPolynomialFactory)}
\item \textit{OrthogonalBasis(otherOrthogonalFunctionFactory)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{orthogonalProductPolynomialFactory}: an OrthogonalProductPolynomialFactory (see details below)
\item \textit{otherOrthogonalFunctionFactory}: an OrthogonalFunctionFactory, it provides to the OrthogonalBasis the persistent types of the univariate orthogonal functions other than polynomials. For example, it can be a WaveletFunctionFactory that will be implemented with the response surface by wavelet expansion.
\end{description}

\item[Value:]  an OrthogonalBasis, which is the interface class of the OrthogonalFunctionFactory implementation, which is an OrthogonalProductPolynomialFactory in the particular case of polynomial chaos expansion.

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{build}
\begin{description}
\item[Usage:] \textit{build(index)}
\item[Arguments:] \textit{index}: an integer that indicates the term of the basis which must be constructed. In other words, \textit{index} is used by a bijection from $\Nset$ to $\Nset^d$ ($d$ is the dimension of the Basis); this bijection is detailed later in EnumerateFunction.
\item[Value:]  a NumericalMathFunction, a term of the basis collection
\end{description}
\bigskip

\item \textit{getMeasure}
\begin{description}
\item[Usage:] \textit{getMeasure()}
\item[Arguments:] none
\item[Value:]  a Distribution, the joint measure that represents the product of the univariate distributions which are respectively orthogonal with respect to the selected univariate function families
\end{description}


\end{description}

\end{description}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!OrthogonalProductPolynomialFactory}
\index{OrthogonalProductPolynomialFactory}
\subsubsection{OrthogonalProductPolynomialFactory}



This class inherits from OrthogonalFunctionFactory
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{OrthogonalProductPolynomialFactory()}
\item \textit{OrthogonalProductPolynomialFactory(polColl)}
\item \textit{OrthogonalProductPolynomialFactory(polColl, enumFct)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{polColl}: a PolynomialFamilyCollection, collection of orthogonal univariate polynomials factories. The collection must have the same dimension as the orthogonal basis.
\item \textit{enumFct}: an EnumerateFunction, that associates to an integer its multi-index image in the $\Nset^d$ dimension, which is the dimension of the basis. This multi-index represents the collection of degrees of the univariate polynomials
\end{description}


\item[Value:]  an OrthogonalProductPolynomialFactory, represents a term of the basis that corresponds to the product of the univariate orthonormal polynomials. Let's note that the exact hessian and gradient have been implemented for the poduct of polynomials.

\item[Some methods :]  \rule{0pt}{1em}
\begin{description}
\item \textit{build}
\begin{description}
\item[Usage:] \textit{build(index)}
\item[Arguments:] \textit{index}: an integer that indicates the term of the basis which must be constructed. In other words, \textit{index} is used by a bijection from $\Nset$ to $\Nset^{dim}$ (recalling that \textit{dim} is the dimension of the \textit{Basis})
\item[Value:]  a NumericalMathFunction, a term of the basis collection
\end{description}
\bigskip

\item \textit{getMeasure}
\begin{description}
\item[Usage:] \textit{getMeasure()}
\item[Arguments:] none
\item[Value:]  a Distribution, the joint measure that represents the product of the univariate distributions which are respectively orthogonal with respect to the selected univariate function families
\end{description}


\end{description}
\item[Details:] OrthogonalProductPolynomialFactory is a particular case of implementation of the OrthogonalFunctionFactory in the case of polynomial chaos expansion. It provides to the OrthogonalBasis the persistent types of the univariate orthogonal polynomials (e.g. Hermite, Legendre, Laguerre and Jacobi) needed to determine the distribution measure of projection of the input variable.

\end{description}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!OrthogonalUniVariatePolynomialFamily}
\index{OrthogonalUniVariatePolynomialFamily}
\subsubsection{OrthogonalUniVariatePolynomialFamily}


OrthogonalUniVariatePolynomialFamily is the interface of the OrthogonalUniVariatePolynomialFactory implementation.
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{OrthogonalUniVariatePolynomialFamily()}
\item \textit{OrthogonalUniVariatePolynomialFamily(orthogUniVarPolFactory)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{orthogUniVarPolFactory}: an OrthogonalUniVariatePolynomialFactory that builds particular univariate polynomial (e.g. Hermite, Legendre, Laguerre, ...).
\end{description}

\item[Value:]  an OrthogonalUniVariatePolynomialFamily, represents the factory that allows the construction of any univariate orthonormal polynomial with any degree.

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{build}
\begin{description}
\item[Usage:] \textit{build(n)}
\item[Arguments:] $n$ : an integer, the degree of the orthogonal polynomial to be build. The polynomial is orthonormal with respect to its associated distribution.
\item[Value:]  a UnivariatePolynomial of the same type as its factory
\end{description}
\bigskip

\item \textit{getMeasure}
\begin{description}
\item[Usage:] \textit{getMeasure()}
\item[Arguments:] none
\item[Value:]  a Distribution, the univariate measure with respect to which the polynomial basis is orthonormal : if the polynomials family is noted $(\Psi_k)_k$ then we have :
\begin{equation}\label{orthono}
<\Psi_k, \Psi_l>_{\mu}  = \delta_{kl}.
\end{equation}
\end{description}
\bigskip

\item \textit{buildCoefficients}
\begin{description}
\item[Usage:]  \textit{buildCoefficients(n)}
\item[Arguments:] $n$ : an integer
\item[Value:]  the sequence $(\alpha_i)_{0 \leq n}$ of the coefficients of the polynomial of degree $n$ :
\begin{equation}\label{coefPol}
P(x) = \sum_{i=0}^{n} \alpha_i x^i
\end{equation}
\end{description}
\bigskip

\item \textit{buildRecurrenceCoefficientsCollection}
\begin{description}
\item[Usage:] \textit{buildRecurrenceCoefficientsCollection(n)}
\item[Arguments:] $n$ : an integer
\item[Value:]  a NumericalSample, which contains the sequence $(a_{0,i}, a_{1,i},a_{2,i})_{1 \leq i \leq n}$ of the three-term recurrence relation that defines the polynomials :

\begin{equation}\label{recCoefPol}
P_{n+1}(x) = (a_{0,n}x+a_{1,n})P_n(x) + a_{2,n}P_{n-1}(x).
\end{equation}
\end{description}

\end{description}
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!StandardDistributionPolynomialFactory}
\index{StandardDistributionPolynomialFactory}
\subsubsection{StandardDistributionPolynomialFactory}

StandardDistributionPolynomialFactory inherits from OrthogonalUniVariatePolynomialFamily.

\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{StandardDistributionPolynomialFactory(distribution)}
\item \textit{StandardDistributionPolynomialFactory(myOrthoAlgo)}
\end{description}


\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{myOrthoAlgo}: a OrthonormalizationAlgorithm,
\item \textit{distribution}: a Distribution of dimension 1, defined by its standard parameters.
\end{description}


\item[Value:] a StandardDistributionPolynomialFactory that evaluates the coefficients of the three term linear recurrence (\ref{recCoefPol}) that defines the orthonormal polynomials associated to the distribution\\

The corresponding polynomials are give here:
\begin{tabular}{l|l}
  Measure & Polynomials \\
  \hline
  Uniform & Legendre (default) \\
  Normal & Hermite \\
  Beta & Jacobi\\
  Gamma & Laguerre \\
  Poisson & Charlier \\
  Binomial & Krawtchouk \\
  NegativeBinomial & Meixner \\
\end{tabular}

When the algorithm is not specified, the Gram-Schmidt algorithm is used with the given distribution.\\
This class detects if the distribution \textit{distribution} directly given or defined in \textit{myOrthoAlgo} is a measure for which the orthonormal polynomials have already been evaluated.

\item[Some methods:] The methods are described in the OrthogonalUniVariatePolynomialFamily class.

\end{description}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!CharlierFactory}
\index{CharlierFactory}
\subsubsection{CharlierFactory}


CharlierFactory inherits from OrthogonalUniVariatePolynomialFamily.

\begin{description}
\item[Usage:] \textit{CharlierFactory($\lambda$)}


\item[Arguments:]  $\lambda$ : a real with $\lambda > 0$. By default, $\lambda = 1$.


\item[Value:]  a CharlierFactory which builds the orthonormalized polynomials with respect to the discrete measure \textit{$\mu$ = Poisson($\lambda$)} as defined in (\ref{orthono}).

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getN}
\begin{description}
\item[Usage:] \textit{getLambda()}
\item[Arguments:] none
\item[Value:]  an real, the $\lambda$ coefficient of the Charlier family.
\end{description}
\bigskip

\item \textit{getMeasure}
\begin{description}
\item[Usage:] \textit{getMeasure()}
\item[Arguments:] none
\item[Value:]  a Distribution, the univariate measure with respect to which the Charlier family is orthonormal. Here the \textit{Poisson($\lambda$)} distribution.
\end{description}
\bigskip

\end{description}
\end{description}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!HermiteFactory}
\index{HermiteFactory}
\subsubsection{HermiteFactory}

HermiteFactory inherits from OrthogonalUniVariatePolynomialFamily.

\begin{description}
\item[Usage:] \textit{HermiteFactory()}


\item[Arguments:]  none

\item[Value:]  an HermiteFactory  which builds the orthonormalized polynomials with respect to the continuous measure \textit{Normal(0,1)} as defined in (\ref{orthono}).

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}
\item \textit{getMeasure}
\begin{description}
\item[Usage:] \textit{getMeasure()}
\item[Arguments:] none
\item[Value:]   a Distribution, the univariate measure with respect to which the Charlier family is orthonormal. Here the \textit{Normal(0,1)} distribution.
\end{description}

\end{description}
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!JacobiFactory}
\index{JacobisFactory}
\subsubsection{JacobiFactory}


JacobiFactory inherits from OrthogonalUniVariatePolynomialFamily.

\begin{description}
\item[Usage:]
\begin{description}
\item \textit{JacobiFactory($\alpha$,$\beta$)}
\item \textit{JacobiFactory($\alpha$,$\beta$, param)}
\end{description}

\item[Arguments:]
\begin{description}
\item $\alpha, \beta$ : two scalars. Both which must be $> -1$ if \textit{param} is equal to Jacobi.ANALYSIS or $0<\alpha<\beta$ if \textit{param} is equal to Jacobi.PROBABILITY.
\item \textit{param}: either Jacobi.ANALYSIS (default value, equivalent to 0), or Jacobi.PROBABILITY (equivalent to 1).
\end{description}

\item[Value:]  a JacobiFactory  which builds the orthonormalized polynomials with respect to the continuous measure \textit{Beta($\beta + 1, \alpha + \beta + 2, -1, 1$)} if \textit{param} is equal to Jacobi.ANALYSIS, or \textit{Beta($\alpha, \beta, -1, 1$)} if \textit{param} is equal to Jacobi.PROBABILITY as defined in (\ref{orthono}).

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}
\item \textit{getMeasure}
\begin{description}
\item[Usage:] \textit{getMeasure()}
\item[Arguments:] none
\item[Value:]  a Distribution, the univariate measure with respect to which the Charlier family is orthonormal. Here the \textit{Beta($\beta + 1, \alpha + \beta + 2, -1, 1$)} distribution.
\end{description}
\bigskip

\item \textit{getAlpha}
\begin{description}
\item[Usage:] \textit{getAlpha()}
\item[Arguments:] none
\item[Value:]  a NumericalScalar, the $\alpha$ coefficient of the Jacobi family.
\end{description}
\bigskip

\item \textit{getBeta}
\begin{description}
\item[Usage:] \textit{getBeta()}
\item[Arguments:] none
\item[Value:]  a NumericalScalar, the $\beta$ coefficient of the Jacobi family.
\end{description}

\end{description}
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!KrawtchoukFactory}
\index{KrawtchoukFactory}
\subsubsection{KrawtchoukFactory}


KrawtchoukFactory inherits from OrthogonalUniVariatePolynomialFamily.

\begin{description}
\item[Usage:] \textit{KrawtchoukFactory(N,p)}


\item[Arguments:]   \rule{0pt}{1em}
\begin{description}
\item $N$ : an integer, $\geq 1$. By default, $N=1$.
\item $p$ : a real, with $0 \leq p \leq 1$. By default, $p=\displaystyle \frac{1}{2}$.
\end{description}


\item[Value:]  a KrawtchoukFactory which builds the orthonormalized polynomials with respect to the discrete measure \textit{$\mu$ = Binomial(N,p)} as defined in (\ref{orthono}).

\item[Some methods :]  \rule{0pt}{1em}


\begin{description}
\item \textit{getMeasure}
\begin{description}
\item[Usage:] \textit{getMeasure()}
\item[Arguments:] none
\item[Value:]  a Distribution, the univariate measure with respect to which the Charlier family is orthonormal. Here the \textit{Binomial(N,p)} distribution.
\end{description}
\bigskip

\item \textit{getN}
\begin{description}
\item[Usage:] \textit{getN()}
\item[Arguments:] none
\item[Value:]  an integer, the $N$ coefficient of the Krawtchouk family.
\end{description}
\bigskip

\item \textit{getP}
\begin{description}
\item[Usage:] \textit{getP()}
\item[Arguments:] none
\item[Value:]  a NumericalScalar, the $p$ coefficient of the Krawtchouk family.
\end{description}

\end{description}
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!LaguerreFactory}
\index{LaguerreFactory}
\subsubsection{LaguerreFactory}

LaguerreFactory inherits from OrthogonalUniVariatePolynomialFamily.

\begin{description}
\item[Usage:]
\begin{description}
\item \textit{LaguerreFactory(k)}
\item \textit{LaguerreFactory(k, param)}
\end{description}

\item[Arguments:]
\begin{description}
\item $k$ : a NumericalScalar which must be $> -1$.
\item \textit{param}: either Laguerre.ANALYSIS (default value, equivalent to 0), or Laguerre.PROBABILITY (equivalent to 1)
\end{description}

\item[Value:]  a LaguerreFactory  which builds the orthonormalized polynomials with respect to the continuous measure \textit{Gamma(k+1,1,0)} if \textit{param} is equal to Laguerre.ANALYSIS, or \textit{Gamma(k, 1, 0)} if \textit{param} is equal to Laguerre.PROBABILITY as defined in (\ref{orthono}).

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}
\item \textit{getMeasure}
\begin{description}
\item[Usage:] \textit{getMeasure()}
\item[Arguments:] none
\item[Value:]  a Distribution, the univariate measure with respect to which the Charlier family is orthonormal. Here the  distribution \textit{Gamma(k+1,1,0)}.
\end{description}
\bigskip

\item \textit{getK}
\begin{description}
\item[Usage:] \textit{getK()}
\item[Arguments:] none
\item[Value:]  a NumericalScalar, the $k$ coefficient of the Laguerre family.
\end{description}

\end{description}
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!LegendreFactory}
\index{LegendreFactory}
\subsubsection{LegendreFactory}


LegendreFactory inherits from OrthogonalUniVariatePolynomialFamily.

\begin{description}
\item[Usage:] \textit{LegendreFactory()}


\item[Arguments:]  none

\item[Value:]  an LegendreFactory which builds the orthonormalized polynomials with respect to the continuous measure \textit{Uniform(-1,1)} distribution as defined in (\ref{orthono}).

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}
\item \textit{getMeasure}
\begin{description}
\item[Usage:] \textit{getMeasure()}
\item[Arguments:] none
\item[Value:]  a Distribution, the univariate measure with respect to which the Charlier family is orthonormal. Here the  distribution \textit{Uniform(-1,1)}.
\end{description}
\end{description}
\end{description}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!MeixnerFactory}
\index{MeixnerFactory}
\subsubsection{MeixnerFactory}


MeixnerFactory inherits from OrthogonalUniVariatePolynomialFamily.

\begin{description}
\item[Usage:] \textit{MeixnerFactory(r,p)}


\item[Arguments:]   \rule{0pt}{1em}
\begin{description}
\item $r$ : a real value $>0$. By default, $r=1$.
\item $p$ : a real, with $0 \leq p \leq 1$. By default, $p=\displaystyle \frac{1}{2}$.
\end{description}


\item[Value:]  an MeixnerFactory which builds the orthonormalized polynomials with respect to the continuous measure \textit{NegativeBinomial(1, 0.5)} distribution as defined in (\ref{orthono}).

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getR}
\begin{description}
\item[Usage:] \textit{getR()}
\item[Arguments:] none
\item[Value:]  a real value, the $r$ coefficient of the Meixner family.
\end{description}
\bigskip

\item \textit{getP}
\begin{description}
\item[Usage:] \textit{getP()}
\item[Arguments:] none
\item[Value:]  a real value, the $p$ coefficient of the Meixner family.
\end{description}
\bigskip

\item \textit{getMeasure}
\begin{description}
\item[Usage:] \textit{getMeasure()}
\item[Arguments:] none
\item[Value:]  a Distribution, the univariate measure with respect to which the Charlier family is orthonormal. Here the  distribution \textit{Negative Binomial(1, 0.5)}.
\end{description}
\end{description}
\end{description}




% -=============================================================

\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!OrthonormalizationAlgorithm}
\index{OrthonormalizationAlgorithm}
\subsubsection{OrthonormalizationAlgorithm}

This class defines the algorithm used to build the orthonormal basis with respect to a specified distribution.

\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{OrthonormalizationAlgorithm(myOrthoAlgo)}
\item \textit{OrthonormalizationAlgorithm(measure)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{measure}: a Distribution
\item \textit{myOrthoAlgo}: a OrthonormalizationAlgorithmImplementation, which is the Chebychev or Gram-Schmidt algorithm
\end{description}


\item[Value:] a OrthonormalizationAlgorithm which enables to build the orthonormal polynomial basis with respect to a distribution.
\begin{description}
\item in the first usage, the algorithm \textit{myOrthoAlgo} is used (that specifies the associated distribution)
\item in the second usage, we use by default the Gram-Schmidt algorithm. Only the distribution \textit{measure} is specified.
\end{description}

\end{description}

% -=============================================================

\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!ChebychevAlgorithm}
\index{ChebychevAlgorithm}
\subsubsection{ChebychevAlgorithm}

This class inherits from OrthonormalizationAlgorithmImplementation.

\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{ChebychevAlgorithm(measure)}
\item \textit{ChebychevAlgorithm(measure, referenceFamily)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{measure}: a Distribution
\item \textit{referenceFamily}: a OrthogonalUniVariatePolynomialFamily. When not specified, the \textit{referenceFamily} is the canonical one : $(1, X, X^2, \hdots, )$.
\end{description}


\item[Value:]  a ChebychevAlgorithm, that builds the orthonormalized polynomials family with respect to the distribution \textit{measure}, where the initial polynomials family is the one specified in \textit{referenceFamily}. It implements the Chebychev algorithm.

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}


\item \textit{getReferenceFamily}
\begin{description}
\item[Usage:] \textit{getReferenceFamily()}
\item[Arguments:] $n$ : an integer
\item[Value:] a OrthogonalUniVariatePolynomialFamily, the polynomials family from which the algorithm starts  to build the  polynomials family which is orthogonal to the distribution \textit{measure}.
\end{description}
\end{description}


\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!GramSchmidtAlgorithm}
\index{GramSchmidtAlgorithm}
\subsubsection{GramSchmidtAlgorithm}

This class inherits from OrthonormalizationAlgorithmImplementation.

\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{GramSchmidtAlgorithm(measure)}
\item \textit{GramSchmidtAlgorithm(measure, referenceFamily)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{measure}: a Distribution
\item \textit{referenceFamily}: a OrthogonalUniVariatePolynomialFamily. When not specified, the \textit{referenceFamily} is the canonical one : $(1, X, X^2, \hdots, )$.
\end{description}


\item[Value:] a GramSchmidtAlgorithm, that builds the orthonormalized polynomials family with respect to the distribution \textit{measure}, where the initial polynomials family is the one specified in \textit{referenceFamily}. It implements the Gram-Schmidt algorithm.

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{getReferenceFamily}
\begin{description}
\item[Usage:] \textit{getReferenceFamily()}
\item[Arguments:] $n$ : an integer
\item[Value:] a OrthogonalUniVariatePolynomialFamily, the polynomials family from which the algorithm starts  to build the  polynomials family which is orthogonal to the distribution \textit{measure}.
\end{description}
\end{description}

\end{description}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!EnumerateFunction}
\index{EnumerateFunction}
\subsubsection{EnumerateFunction}

\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{EnumerateFunction()}
\item \textit{EnumerateFunction(dim)}
\item \textit{EnumerateFunction(implementation)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{dim}: an integer, that represents the dimension of the EnumerateFunction. \textit{dim} must be equal to the dimension of the OrthogonalBasis.
\item \textit{implementation}: an EnumerateFunctionImplementation, which is a particular enumerate function
\end{description}

\item[Value:]  an EnumerateFunction, which is a function that maps $\Nset$ into $\Nset^{dim}$. In the default constructor $dim~=~0$.

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}

\item \textit{inverse}
\begin{description}
\item[Usage:] \textit{inverse(multiIndex)}
\item[Arguments:] \textit{multiIndex}: an Indices, which is a collection of integers
\item[Value:]  an integer, represents the antecedent of the \textit{multiIndex} in the EnumerateFunction.
\end{description}
\bigskip

\item \textit{getStrataCardinal}
\begin{description}
\item[Usage:] \textit{getStrataCardinal(strateIndex)}
\item[Arguments:] \textit{strateIndex}: an integer, the index of the strata in the hierarchical basis. In the context of product of polynomial basis, this is the total polynom degree.
\item[Value:] the number of members of the basis associated to the strata \textit{strateIndex}. In the context of product of polynomial basis, this is the number of polynoms of the basis which total degree is \textit{strateIndex}.
\end{description}
\bigskip

\item \textit{getStrataCumulatedCardinal}
\begin{description}
\item[Usage:] \textit{getStrataCumulatedCardinal(strateIndex)}
\item[Arguments:] \textit{strateIndex}: an integer, the index of the strate in the hierarchical basis. In the context of product of polynomial basis, this is the total polynomial degree.
\item[Value:] the number of members of the basis associated to the  strates inferior or equal to \textit{strateIndex}. In the context of product of polynomial basis, this is the number of polynomials of the basis which total degree is inferior or equal to \textit{strateIndex}.
\end{description}
\bigskip

\item \textit{getMaximumDegreeStrataIndex}
\begin{description}
\item[Usage:] \textit{getMaximumDegreeStrataIndex(maximumDegree)}
\item[Arguments:] \textit{maximumDegree}: an integer, the degree
\item[Value:] the index of the strata of degree max \textit{$<$ maximumDegree}
\end{description}
\bigskip

\item \textit{getMaximumDegreeCardinal}
\begin{description}
\item[Usage:] \textit{getMaximumDegreeCardinal(maximumDegree)}
\item[Arguments:] \textit{maximumDegree}: an integer, the number of polynoms of the basis
\item[Value:] an integer, the cardinal of indices of degree \textit{max <= maximumDegree}
\end{description}
\bigskip

\item \textit{getDimension}
\begin{description}
\item[Usage:] \textit{getDimension()}
\item[Arguments:] none
\item[Value:] an integer, the dimension of the EnumerateFunction.
\end{description}

\end{description}
\item[Details:] \textit{EnumerateFunction} represents a bijection from $\Nset$ to $\Nset^{dim}$. This bijection is based on a particular procedure of enumerating the set of multi-indices. It begins from the multi-index $[0,0,...,0]$. \\We associate a multi-index $[j_{p1}, j_{p2},..., j_{pdim}]$ for every integer $i_p$ in $\Nset$: \\ For more details, let us consider any $i_p, i_q~\in~\Nset$: if $|i_p-i_q|\leq 1$ then $|\sum_{k=1}^{dim}~(j_{pk}- j_{qk})| \leq 1$. This proposition provides a necessary but unsufficient condition for the construction of the bijection. Another assumption was done indicating the way of iteration. Below an example showing this assumption.\\
Example:
for $dim~=~2$,
\begin{eqnarray*}
phi(0) &=& [0~~~0] \\
phi(1) &=& [1~~~0] \\
phi(2) &=& [0~~~1] \\
phi(3) &=& [2~~~0] \\
phi(4) &=& [1~~~1] \\
phi(5) &=& [0~~~2] \\
phi(6) &=& [3~~~0] \\
\end{eqnarray*}
\end{description}

For the functional expansion (respectively polynomial chaos expansion), the multi-index $\underline{i_p}$ represents the collection of degrees of the selected orthogonal functions (respectively orthogonal polynomials). In fact, after the selection of the type of orthogonal functions (respectively orthogonal polynomials) for the construction of the orthogonal basis, the \textit{EnumerateFunction} characterizes the term of the basis by providing the degrees of the univariate functions (respectively univariate polynomials).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!LinearEnumerateFunction}
\index{LinearEnumerateFunction}
\subsubsection{LinearEnumerateFunction}

LinearEnumerateFunction inherits from EnumerateFunctionImplementation.

\begin{description}
\item[Usage:] \strut
\begin{description}
\item \textit{LinearEnumerateFunction(dim)}
\end{description}

\item[Arguments:]  \strut
\begin{description}
\item \textit{dim}: an integer, that represents the dimension of the EnumerateFunction. \textit{dim} must be equal to the dimension of the OrthogonalBasis.
\end{description}

\item[Value:] a LinearEnumerateFunction

% \item[Some methods :]  \strut
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the multivariate orthogonal basis!HyperbolicAnisotropicEnumerateFunction}
\index{HyperbolicAnisotropicEnumerateFunction}
\subsubsection{HyperbolicAnisotropicEnumerateFunction}

HyperbolicAnisotropicEnumerateFunction inherits from EnumerateFunctionImplementation.

\begin{description}
\item[Usage:] \strut
\begin{description}
\item \textit{HyperbolicAnisotropicEnumerateFunction( dim )}
\item \textit{HyperbolicAnisotropicEnumerateFunction( dim, q )}
\item \textit{HyperbolicAnisotropicEnumerateFunction( weight )}
\item \textit{HyperbolicAnisotropicEnumerateFunction( weight, q )}
\end{description}

\item[Arguments:]  \strut
\begin{description}
\item \textit{dim}: an UnsignedLong, that represents the dimension of the EnumerateFunction. \textit{dim} must be equal to the dimension of the OrthogonalBasis.
\item $q$ : a NumericalScalar, the q-quasi-norm parameter.
\item \textit{weight}: a NumericalPoint, the weights of the indices in each dimension.
\end{description}

\item[Value:] an HyperbolicAnisotropicEnumerateFunction

% \item[Some methods :]  \strut
\end{description}

\begin{description}
\bigskip
\item \textit{getStrateCumulatedCardinal}
\begin{description}
\item[Usage:] \textit{getStrateCumulatedCardinal(strateIndex)}
\item[Arguments:] \textit{strateIndex}: an integer, the index of the strate in the hierarchical basis. In the context of product of polynomial basis, this is the total polynom degree.
\item[Value:] the number of members of the basis associated to the  strates inferior or equal to \textit{strateIndex}. In the context of product of polynomial basis, this is the nulber of polynoms of the basis which total degree is inferior or equal to \textit{strateIndex}.
\end{description}

\end{description}
\begin{description}

\item[Details:] \textit{EnumerateFunction} represents a bijection from $\Nset$ to $\Nset^{dim}$. This bijection is based on a particular procedure of enumerating the set of multi-indices. It begins from the multi-index $[0,0,...,0]$. \\We associate a multi-index $[j_{p1}, j_{p2},..., j_{pdim}]$ for every integer $i_p$ in $\Nset$: \\ For more details, let us consider any $i_p, i_q~\in~\Nset$: if $|i_p-i_q|\leq 1$ then $|\sum_{k=1}^{dim}~(j_{pk}- j_{qk})| \leq 1$. This proposition provides a necessary but unsufficient condition for the construction of the bijection. Another assumption was done indicating the way of iteration. Below an example showing this assumption.\\
Example:
for $dim~=~2$,
\begin{eqnarray*}
phi(0) &=& [0~~~0] \\
phi(1) &=& [1~~~0] \\
phi(2) &=& [0~~~1] \\
phi(3) &=& [2~~~0] \\
phi(4) &=& [1~~~1] \\
phi(5) &=& [0~~~2] \\
phi(6) &=& [3~~~0] \\
\end{eqnarray*}
For the functional expansion (respectively polynomial chaos expansion), the multi-index $\underline{i_p}$ represents the collection of degrees of the selected orthogonal functions (respectively orthogonal polynomials). In fact, after the selection of the type of orthogonal functions (respectively orthogonal polynomials) for the construction of the orthogonal basis, the \textit{EnumerateFunction} characterizes the term of the basis by providing the degrees of the univariate functions (respectively univariate polynomials).

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the truncated multivariate orthogonal basis}
\subsection{Construction of the truncated multivariate orthogonal basis}

These strategies are conceived in such a way to be adapted for other orthogonal expansions (other than polynomial). They provide the strategies of selection of different terms of the basis in which the response surface by functional chaos is expressed. For the moment, their implementation are useful for the polynomial chaos expansion.




% \index{Response Surface : Functional Chaos Expansion!Construction of the truncated multivariate orthogonal basis!AdaptiveStrategy}
\index{AdaptiveStrategy}
\subsubsection{AdaptiveStrategy}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{AdaptiveStrategy(orthogonalBasis, size)}
\item \textit{AdaptiveStrategy(adaptiveStrategyImplementation)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{orthogonalBasis}: an OrthogonalBasis
\item \textit{size}: provides the number of terms of the basis. This first usage has the same implementation as the second (with a FixedStrategy). The difference is that the size of the basis is provided directly to the AdaptiveStrategy. (See below the FixedStrategy)
\item \textit{adaptiveStrategyImplementation}: an adaptiveStrategyImplementation which is a FixedStrategy, a SequentialStrategy or a CleaningStrategy.
\end{description}

\item[Value:]  an AdaptiveStrategy, such as :
\begin{description}
\item in the first usage, the adaptive strategy is by default the FixedStrategy.
\item in the first usage, the adaptive strategy is specified.
\end{description}

\item[Some methods :]  \rule{0pt}{1em}

\begin{description}
\item \textit{getMaximumDimension}
\begin{description}
\item[Usage:] \textit{getMaximumDimension()}
\item[Arguments:] none
\item[Value:]  an integer which is the size of the truncated basis .
\end{description}

\end{description}

\end{description}

The \textit{getMaximumDimension} has its associated \textit{setMaximumDimension}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the truncated multivariate orthogonal basis!FixedStrategy}
\index{FixedStrategy}
\subsubsection{FixedStrategy}
FixedStrategy inherits from AdaptiveStrategyImplementation
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{FixedStrategy(orthogonalBasis, size)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{orthogonalBasis}: an OrthogonalBasis
\item \textit{size}: provides the number of terms of the basis.
\end{description}

\item[Value:] a FixedStrategy

\item[Details:] it is a fixed strategy in the sense that all terms of the basis are built once and for all :  that means they can be determined before the projection in the basis. The basis is determined by iterating the \textit{EnumerateFunction} a $size -1$ times from the first term $\underline{i_1}=[0,...,0]$. In this strategy, we can find the so-called \emph{complete basis}, by setting $size = C_{dim+p}^{dim}$ with $p$ the degree of the chaos expansion.
\end{description}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the truncated multivariate orthogonal basis!SequentialStrategy}
\index{SequentialStrategy}
\subsubsection{SequentialStrategy}
SequentialStrategy inherits from AdaptiveStrategyImplementation

\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{SequentialStrategy(orthogonalBasis, maximumSize)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{orthogonalBasis}: an OrthogonalBasis
\item \textit{maximumSize}: provides the maximum number of terms of the truncated basis.
\end{description}

\item[Value:] a SequentialStrategy.

\item[Details:] The SequentialStrategy  generates, term by term, the basis using the Enumerate function. It begins from index = 0 and continues, till satisfying a convergence criterion (that is the residual of the least squares algorithm in the case of the LeastSquaresStrategy) or till reaching the maximal index of terms generation fixed by the user.
\end{description}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Construction of the truncated multivariate orthogonal basis!CleaningStrategy}
\index{CleaningStrategy}
\subsubsection{CleaningStrategy}

CleaningStrategy inherits from AdaptiveStrategyImplementation

\begin{description}

\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{CleaningStrategy(orthoBas, indexMaxOfBasis)}
\item \textit{CleaningStrategy(orthoBas, indexMaxOfBasis, verbose)}
\item \textit{CleaningStrategy(orthoBas, indexMaxOfBasis, maxSizeOfBasis, significanceFactor)}
\item \textit{CleaningStrategy(orthoBas, indexMaxOfBasis, maxSizeOfBasis, significanceFactor, verbose)}

\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{orthoBas}: an OrthogonalBasis
\item \textit{indexMaxOfBasis}: an integer, the index maximum that can be used by the \textit{EnumerateFunction} to determine the last term of the basis
\item \textit{maxSizeOfBasis}: an integer, this parameter characterizes the \textit{CleaningStrategy}. In fact, it represents the number of efficient coefficients of the basis. Its default value is equal to $20$
\item \textit{significanceFactor}: an integer, used as a threshold for selection the efficient coefficients of the basis. (the real threshold represents the multiplication of the significanceFactor with the maximum magnitude of the current coefficients determined). Its default value is equal to $1e^{-4}$
\item \textit{verbose}: a boolean, needed when we are interested in the online monitoring of the current basis updates. (removed or added coefficients)
\end{description}

\item[Value:] a CleaningStrategy
\item[Details:] This strategy aims to filter the basis from unsignificant terms. After choosing the maximum index and the size of the basis, the strategy calculates an initial basis of, for example, $20$ terms, the unsignificant coefficients are removed (w.r.t a significance factor) and another coefficients are calculated. This procedure continues till arriving to the \textit{indexMaxOfBasis} of the basis or till satisfying the residual of the least squares algorithm.
\end{description}











%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Evaluation of the coefficients}

These strategies are conceived in such a way to be adapted for other orthogonal expansions (other than polynomial). They provide different strategies of projection in the orthonormal basis. For the moment, their implementation are useful for the polynomial chaos expansion.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \index{Response Surface : Functional Chaos Expansion!Evaluation of the coefficients!ProjectionStrategy}
\index{ProjectionStrategy}
\subsubsection{ProjectionStrategy}

This class is not usable because it has sense only within the FunctionalChoasAlgorithm.


\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{ProjectionStrategy(projectionStrategyImplementation)}
\end{description}

\item[Arguments:]  \rule{0pt}{1em}
\begin{description}
\item \textit{projectionStrategyImplementation}: a ProjectionStrategyImplementation which is a LeastSquaresStrategy or a IntegrationStrategy (detailed further).
\end{description}

\item[Value:]  a ProjectionStrategy, which is the interface of the ProjectionStrategyImplementation. It represents a generic class (virtual) for different strategies like: LeastSquaresStrategy, IntegrationStrategy.

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Evaluation of the coefficients!LeastSquaresStrategy}
\index{LeastSquaresStrategy}
\subsubsection{LeastSquaresStrategy}

This class inherits from ProjectionStrategyImplementation.\\

This class is not usable because it has sense only within the FunctionalChoasAlgorithm : the least squares strategy evaluates the coefcients $(\alpha_k)_{k \in K}$ of the polynomials decomposition as follows :
\begin{equation}\label{defArgMin}
\vect{\alpha} = argmin_{\vect{\alpha} \in \Rset^K} E_{\mu} \left[ \left( g \circ T^{-1}(\vect{Z}) -  \sum_{k \in K} \alpha_k \Psi_k (\vect{Z})\right)^2  \right]
\end{equation}
where $\vect{Z} = T(\vect{X})$.\\
Then, the esperance $ E_{\mu}$ is approximated by a relation of type :
\begin{equation}\label{approxEsp}
E_{\mu} \left[ f(\vect{Z}) \right] \simeq \sum_{i \in I} \omega_i f(\Xi_i)
\end{equation}
where $f$ is a function $L_1(\mu)$ defined as :
\begin{equation}\label{fArgMin}
f(\vect{Z}) = \left( g \circ T^{-1}(\vect{Z}) -  \sum_{k \in K} \alpha_k \Psi_k (\vect{Z})\right)^2
\end{equation}
In the approximation (\ref{approxEsp}), the set $I$, the points $(\Xi_i)_{i \in I}$ and the weights $(\omega_i)_{i \in I}$ are evaluated from different methods implemented in OpenTURNS in the \emph{WeightedExeriment}.


\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{LeastSquaresStrategy(weightedExperiment)}
\item \textit{LeastSquaresStrategy(weightedExp, approxAlgoImpFact)}
\item \textit{LeastSquaresStrategy(measure, approxAlgoImpFact)}
\item \textit{LeastSquaresStrategy(measure, weightedExp, approxAlgoImpFact)}
\item \textit{LeastSquaresStrategy(inputSample, weights, outputSample, approxAlgoImpFact)}
\end{description}

\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{weightedExp}: a WeightedExperiment, the experimental design used for the transformed input data. When not precised, OpenTURNS uses a \textit{MonteCarloExperiment}.
\item \textit{approxAlgoImpFact}: an ApproximationAlgorithmImplementationFactory, the factory that builds the desired ApproximationAlgorithm. When not precised, OpenTURNS uses the \emph{PenalizedLeastSquaresAlgorithmFactory}.
\item \textit{measure}: the Distribution $\mu$ with respect to which the basis is orthonormal. When not precised, OpenTURNS uses the limit peasure defined within the WeightedExperiment.
\item \textit{inputSample}, \textit{outputSample}: two NumericalSample that describe the model.
\item \textit{weights}: a NumericalPoint that are the weights associated to the input sample points such that the corresponding WeightedExperiment is a good approximation of $\mu$.
\end{description}


\item[Value:]  a LeastSquaresStrategy used to create a \textit{FunctionalChaosAlgorithm}.

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Evaluation of the coefficients!IntegrationStrategy}
\index{IntegrationStrategy}
\subsubsection{IntegrationStrategy}

This class inherits from ProjectionStrategyImplementation.\\

This class is not usable because it has sense only within the FunctionalChoasAlgorithm : the integration strategy evaluates the coefficients $(\alpha_k)_{k \in K}$ of the polynomials decomposition as follows :
\begin{equation}\label{defEsp}
\vect{\alpha} = \left( E_{\mu} \left[ g \circ T^{-1}(\vect{Z}) \Psi_k (\vect{Z}) \right]\right)_k
\end{equation}
where $\vect{Z} = T(\vect{X})$.\\
Then, the expectation $ E_{\mu}$ is approximated by a relation of type :
\begin{equation}\label{approxEsp3}
E_{\mu} \left[ f(\vect{Z}) \right] \simeq \sum_{i \in I} \omega_i f(\xi_i)
\end{equation}
where $f$ is a function $L_1(\mu)$ defined as :
\begin{equation}\label{fEsp}
f(\vect{Z}) = g \circ T^{-1}(\vect{Z}) \Psi_k (\vect{Z})
\end{equation}
In the approximation (\ref{approxEsp3}), the set $I$, the points $(\xi_i)_{i \in I}$ and the weights $(\omega_i)_{i \in I}$ are evaluated from different methods implemented in OpenTURNS in the \emph{WeightedExeriment}.



\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{IntegrationStrategy(measure)}
\item \textit{IntegrationStrategy(weightedExperiment)}
\item \textit{IntegrationStrategy(measure, weightedExp)}
\item \textit{IntegrationStrategy(inputSample, outputSample)}
\end{description}

\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{weightedExp}: a WeightedExperiment, the experimental design used for the transformed input data. When not precised, OpenTURNS uses a \textit{MonteCarloExperiment}.
\item \textit{approxAlgoImpFact}: an ApproximationAlgorithmImplementationFactory, the factory that builds the desired ApproximationAlgorithm. When not precised, OpenTURNS uses the \emph{PenalizedLeastSquaresAlgorithmFactory}.
\item \textit{measure}: the Distribution $\mu$ with respect to which the basis is orthonormal. When not precised, OpenTURNS uses the limit peasure defined within the WeightedExperiment.
\item \textit{inputSample}, \textit{outputSample}: two NumericalSample that describe the model.
\item \textit{weights}: a NumericalPoint that are the weights associated to the input sample points such that the corresponding WeightedExperiment is a good approximation of $\mu$.
\end{description}


\item[Value:]  a IntegrationStrategy used to create a \textit{FunctionalChaosAlgorithm}.

\end{description}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Evaluation of the coefficients!ApproximationAlgorithmFactory}
\index{ApproximationAlgorithmFactory}
\subsubsection{ApproximationAlgorithmFactory}

\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{ApproximationAlgorithmFactory(approxAlgoImpFact)}
\end{description}

\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{approxAlgoImpFact}: an ApproximationAlgorithmImplementationFactory (detailed later).
\end{description}


\item[Value:] an ApproximationAlgorithmFactory, which is the interface of the ApproximationAlgorithmImplementationFactory. It represents a generic class (virtual) for different factories like: PenalizedLeastSquaresAlgorithmFactory, PenalizedLeastSquaresAlgorithmFactory ...

\item[Some methods :] This class is not usable because it has sense only whithin the FunctionalChoasAlgorithm.

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Evaluation of the coefficients!PenalizedLeastSquaresAlgorithmFactory}
\index{PenalizedLeastSquaresAlgorithmFactory}
\subsubsection{PenalizedLeastSquaresAlgorithmFactory}

PenalizedLeastSquaresAlgorithmFactory inherits from ApproximationAlgorithmImplementationFactory.

\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{PenalizedLeastSquaresAlgorithmFactory()}
\end{description}

\item[Value:] a PenalizedLeastSquaresAlgorithmFactory, implementation of ApproximationAlgorithmFactory which builds an ApproximationAlgorithmImplementation.

\item[Some methods :]  This class is not usable because it has sense only whithin the FunctionalChoasAlgorithm.

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Evaluation of the coefficients!LeastSquaresMetaModelSelectionFactory}
\index{LeastSquaresMetaModelSelectionFactory}
\subsubsection{LeastSquaresMetaModelSelectionFactory}

LeastSquaresMetaModelSelectionFactory inherits from ApproximationAlgorithmImplementationFactory.

\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{LeastSquaresMetaModelSelectionFactory( )}
\item \textit{LeastSquaresMetaModelSelectionFactory( basisSequenceFactory )}
\item \textit{LeastSquaresMetaModelSelectionFactory( basisSequenceFactory, fittingAlgorithm )}
\end{description}

\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item basisSequenceFactory : a BasisSequenceFactory (detailed later).
\item fittingAlgorithm : a FittingAlgorithm (detailed later).
\end{description}

\item[Value:] a LeastSquaresMetaModelSelectionFactory, implementation of ApproximationAlgorithmImplementationFactory which builds an ApproximationAlgorithm.

\item[Some methods :]  This class is not usable because it has sense only whithin the FunctionalChoasAlgorithm.

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Evaluation of the coefficients!BasisSequenceFactory}
\index{BasisSequenceFactory}
\subsubsection{BasisSequenceFactory}

\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{BasisSequenceFactory(basisSequenceFactoryImplementation)}
\end{description}

\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item basisSequenceFactoryImplementation : a BasisSequenceFactoryImplementation (detailed later).
\end{description}

\item[Value:]  a BasisSequenceFactory, which is the interface of the BasisSequenceFactoryImplementation. It represents a generic class (virtual) for different strategies like: LAR.

\item[Some methods :]  This class is not usable because it has sense only whithin the FunctionalChoasAlgorithm.

\end{description}



% \index{Response Surface : Functional Chaos Expansion!Evaluation of the coefficients!LAR}
\index{LAR}
\subsubsection{LAR}

LAR inherits from BasisSequenceFactory.

\begin{description}
\item[Usage:] \strut
\begin{description}
\item \textit{LAR()}
\end{description}

\item[Value:]  a LAR

\item[Some methods :]  This class is not usable because it has sense only whithin the FunctionalChoasAlgorithm.

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
% \index{Response Surface : Functional Chaos Expansion!Evaluation of the coefficients!FittingAlgorithm}
\index{FittingAlgorithm}
\subsubsection{FittingAlgorithm}

\begin{description}
\item[Usage:] \strut
\begin{description}
\item \textit{FittingAlgorithm(fittingAlgorithmImplementation)}
\end{description}

\item[Arguments:]  \strut
\begin{description}
\item fittingAlgorithmImplementation : a FittingAlgorithmImplementation (detailed later).
\end{description}

\item[Value:]  a FittingAlgorithm, which is the interface of the FittingAlgorithmImplementation. It represents a generic class (virtual) for different cross-validation algorithms like: CorrectedLeaveOneOut, KFold...

\item[Some methods :]  This class is not usable because it has sense only whithin the FunctionalChoasAlgorithm.

\end{description}

% \index{Response Surface : Functional Chaos Expansion!Evaluation of the coefficients!CorrectedLeaveOneOut}
\index{CorrectedLeaveOneOut}
\subsubsection{CorrectedLeaveOneOut}

CorrectedLeaveOneOut inherits from FittingAlgorithmImplementation.

\begin{description}
\item[Usage:] \strut
\begin{description}
\item \textit{CorrectedLeaveOneOut()}
\end{description}

\item[Value:] a CorrectedLeaveOneOut

\item[Some methods :] This class is not usable because it has sense only whithin BasisSequenceFactory.

\end{description}

% \index{Response Surface : Functional Chaos Expansion!Evaluation of the coefficients!KFold}
\index{KFold}
\subsubsection{KFold}
KFold inherits from FittingAlgorithmImplementation.

\begin{description}
\item[Usage:] \strut
\begin{description}
\item \textit{KFold( )}
\item \textit{KFold( k )}
\end{description}

\item[Arguments:]  \strut
\begin{description}
\item k : an integer, decides the number of folds in which the sample is splitted.
\end{description}

\item[Value:] a KFold

\item[Some methods :]  This class is not usable because it has sense only whithin the FunctionalChoasAlgorithm.

\end{description}




% -=============================================================

\newpage
% \index{Response Surface : Functional Chaos Expansion!FunctionalChaosRandomVector}
\index{FunctionalChaosRandomVector}
\subsection{FunctionalChaosRandomVector}

This structure is created from a FunctionalChaosResult in order to evaluate the Sobol indices associated to the polynomial chaos decomposition of the model.

\begin{description}

\item[Usage:]   \textit{FunctionalChaosRandomVector(functionalChaosResult)}

\item[Arguments:]  \textit{functionalChaosResult}: a FunctionalChaosResult resulting from a polynomial chaos decomposition of the model


\item[Value:]  a FunctionalChaosRandomVector


\item[Some methods :]  \rule{0pt}{1em}
\begin{description}


\item \textit{getMean}
\begin{description}
\item[Usage:] \textit{getMean()}
\item[Arguments:] none
\item[Value:] a NumericalPoint, the mean of the random vector defined as the result of the polynomial chaos approximation. The mean is the first coefficient (constant term) of the polynomial decomposition.
\end{description}
\bigskip

\item \textit{getCovariance}
\begin{description}
\item[Usage:] \textit{getCovariance()}
\item[Arguments:] none
\item[Value:] a CovarianceMatrix, the covariance of the random vector defined as the result of the polynomial chaos approximation. The covariance is the sum of the square coefficients except the first one (constant term) minus the suqare of the constant term of the polynomial decomposition.
\end{description}
\bigskip

\item \textit{getFunctionalChaoResult}
\begin{description}
\item[Usage:] \textit{getFunctionalChaoResult()}
\item[Arguments:] none
\item[Value:] the FunctionalChaosResult resulting from the polynomial chaos decomposition of the model
\end{description}
\bigskip

\item \textit{getSobolIndex}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{getSobolIndex(variableIndices)}
\item \textit{getSobolIndex(variableIndex)}
\end{description}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{variableIndices}: a Indices, indicating the set of variables for which we want the associated Sobol indice
\item \textit{variableIndex}: a UnsignedLong indicating the variable  for which we want the associated Sobol indices
\end{description}
\item[Value:] a NumericalScalar, the Sobol indice
\end{description}
\bigskip

\item \textit{getTotalSobolIndex}
\begin{description}
\item[Usage:] \rule{0pt}{1em}
\begin{description}
\item \textit{getSobolTotalIndex(variableIndices)}
\item \textit{getSobolTotalIndex(variableIndex)}
\end{description}
\item[Arguments:] \rule{0pt}{1em}
\begin{description}
\item \textit{variableIndices}: a Indices, indicating the variables for which we want the associated Sobol indices
\item \textit{variableIndex}: a UnsisignedLong indicating the variable  for which we want the associated Sobol indices
\end{description}
\item[Value:] a NumericalScalar, the Total Sobol indice

\end{description}

\end{description}

\end{description}
