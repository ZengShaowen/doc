% Copyright (C) 2005-2015 Airbus - EDF - IMACS - Phimeca
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts.  A copy of the license is included in the section entitled "GNU
% Free Documentation License".
\newpage
\extanchor{optimization}
\section{Optimization}

% \index{Optimization!Minimization of the distance under an equality constraint}
\subsection{Minimization of the distance under an equality constraint}

% \index{Optimization!Minimization of the distance under an equality constraint!NearestPointAlgorithm}
\index{NearestPointAlgorithm}
\subsubsection{NearestPointAlgorithm}

\begin{description}
\item[Usage:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{NearestPointAlgorithm(levelFunction)}
  \item \textit{NearestPointAlgorithm(nearestPointAlgorithmImplementation)}
  \end{description}

\item[Arguments:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{levelFunction}: a NumericalMathFunction, the constraint function of the constrained optimization problem.
  \item \textit{nearestPointAlgorithmImplementation}: a NearestPointAlgorithmImplementation, the implementation of the nearest point algorithm, which is \textit{Cobyla} , \textit{AbdoRackwitz} or \textit{SQP}.
  \end{description}

\item[Details:] a NearestPointAlgorithm, which resolves the optimization problem:
  \begin{align*}
    \min_{f(\vect{u}) = 0} ||\vect{U}||^2
  \end{align*}
  where $f$ is the \textit{levelFunction}.
  \begin{description}
  \item in the first usage, the optimization algorithm is the Cobyla one with its default specific parameters.
  \item in the second usage, the optimization algorithm is specified by the \textit{nearestPointAlgorithmImplementation}.
  \end{description}

\item[Some methods:]  \rule{0pt}{1em}

  \begin{description}

  \item \textit{getLevelFunction}
    \begin{description}
    \item[Usage:] \textit{getLevelFunction()}
    \item[Arguments:] none
    \item[Value:]  a NumericalMathFunction, the constraint function of the constrained optimization problem
    \end{description}
    \bigskip

  \item \textit{getLevelValue}
    \begin{description}
    \item[Usage:] \textit{getLevelValue()}
    \item[Arguments:] none
    \item[Value:]  a real value, the value of the constraint function in the constrained optimization problem
    \end{description}
    \bigskip

  \item \textit{getMaximumAbsoluteError}
    \begin{description}
    \item[Usage:] \textit{getMaximumAbsoluteError()}
    \item[Arguments:] none
    \item[Value:] a positive real value, the maximum value of the absolute  error defined in (\ref{absError}) defining the convergence criteria of the algorithm.
    \end{description}
    \bigskip

  \item \textit{getMaximumConstraintError}
    \begin{description}
    \item[Usage:] \textit{getMaximumConstraintError()}
    \item[Arguments:] none
    \item[Value:] a positive real value, the maximum value of the constraint error defined in (\ref{consError}) defining the convergence criteria of the algorithm.
    \end{description}
    \bigskip

  \item \textit{getMaximumIterationsNumber}
    \begin{description}
    \item[Usage:] \textit{getMaximumIterationsNumber()}
    \item[Arguments:] none
    \item[Value:] an integer, the maximum number of iterations of the algorithm defining the convergence criteria  of the algorithm.
    \end{description}
    \bigskip

  \item \textit{getMaximumRelativeError}
    \begin{description}
    \item[Usage:] \textit{geMaximumtRelativeError()}
    \item[Arguments:] none
    \item[Value:] a real value, the maximum value of the relative  error defined in (\ref{relError}) defining the convergence criteria of the algorithm. 
    \end{description}
    \bigskip

  \item \textit{getMaximumResidualError}
    \begin{description}
    \item[Usage:] \textit{getMaximumResidualError()}
    \item[Arguments:] none
    \item[Value:] a real value, the maximum value of the residual  error defined in (\ref{resError}) defining the convergence criteria of the algorithm. 
    \end{description}
    \bigskip

  \item \textit{getResult}
    \begin{description}
    \item[Usage:] \textit{getResult()}
    \item[Arguments:] none
    \item[Value:] a NearestPointAlgorithmImplementationResult, the structure containing all the results of the constrained optimization problem
    \end{description}
    \bigskip

  \item \textit{getStartingPoint}
    \begin{description}
    \item[Usage:] \textit{getStartingPoint()}
    \item[Arguments:] none
    \item[Value:] a NumericalPoint, the starting point of the constrained optimization research
    \end{description}
    \bigskip

  \item \textit{run}
    \begin{description}
    \item[Usage:] \textit{run()}
    \item[Arguments:] none
    \item[Value:] none
    \item[Role:] it creates a NearestPointAlgorithmImplementationResult, the optimization result which is accessible with the method getResult().
    \end{description}
  \end{description}

  Each  \textit{getMethod}  is associated to a \textit{setMethod}.


\end{description}

% =============================================================
\newpage
% \index{Optimization!Minimization of the distance under an equality constraint!Cobyla}
\index{Cobyla}
\subsubsection{Cobyla}

This class inherits from the NearestPointAlgorithmImplementation class.
\begin{description}
\item[Usage:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{Cobyla()}
  \item \textit{Cobyla(specificParameters,  levelFunction)}
  \end{description}

\item[Arguments:]  \rule{0pt}{1em}
  \begin{description}
  \item \textit{specificParameters}: a CobylaSpecificParameters, the list of the parameters specific to the Cobyla algorithm
  \item \textit{levelFunction}: a NumericalMathFunction, the constraint function of the constrained optimization problem
  \end{description}

\item[Details:]  When no argument is specified, the parameters will have to be fulfilled after, for example, when used in a FORM algorithm (see the corresponding Use Case).

\item[Some methods:]  \rule{0pt}{1em}

  \begin{description}

  \item \textit{getSpecificParameters}
    \begin{description}
    \item[Usage:] \textit{getSpecificParameters()}
    \item[Arguments:] none
    \item[Value:]  a CobylaSpecificParameters, the list of the parameters specific to the Cobyla algorithm
    \end{description}
    \bigskip
  \end{description}

  This  \textit{getMethod}  is associated to a \textit{setMethod}.

\end{description}

% =============================================================
\newpage
% \index{Optimization!Minimization of the distance under an equality constraint!CobylaSpecificParameters}
\index{CobylaSpecificParameters}
\subsubsection{CobylaSpecificParameters}


\begin{description}
\item[Usage:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{CobylaSpecificParameters()}
  \item \textit{CobylaSpecificParameters(rhoBeg)}
  \end{description}

\item[Arguments:]  \textit{rhoBeg}:  a real positive strictly value, a reasonable initial step to the variables.

\item[Values:]  \rule{0pt}{1em}

  \begin{description}
  \item in the first usage, the default values are considered for each parameter: \textit{rhoBeg = 0.1}.
  \item  in the second usage, the parameter \textit{rhoBeg} is specified.
  \end{description}




\item[Some methods:]  \rule{0pt}{1em}

  \begin{description}

  \item \textit{getRhoBeg}
    \begin{description}
    \item[Usage:] \textit{getRhoBeg()}
    \item[Arguments:] none
    \item[Value:]  a real value >0, a reasonable initial step to the variables
    \end{description}
    \bigskip
  \end{description}

  This  \textit{getMethod}  is associated to a \textit{setMethod}.
\end{description}
% =============================================================
\newpage
% \index{Optimization!Minimization of the distance under an equality constraint!AbdoRackwitz}
\index{AbdoRackwitz}
\subsubsection{AbdoRackwitz}

This class inherits from the NearestPointAlgorithmImplementation class.

\begin{description}
\item[Usage:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{AbdoRackwitz()}
  \item \textit{AbdoRackwitz(specificParameters,  levelFunction)}
  \end{description}

\item[Arguments:]  \rule{0pt}{1em}
  \begin{description}
  \item \textit{specificParameters}: a AbdoRackwitzSpecificParameters, the list of the parameters specific to the AbdoRackwitz algorithm
  \item \textit{levelFunction}: a NumericalMathFunction, the constraint function of the constrained optimization problem
  \end{description}

\item[Details:]  When no argument is specified, the parameters will have to be fulfilled after, for example, when used in a FORM algorithm (see the corresponding Use Case).

  The AbdoRackwitz algorithm is a gradient-based constrained optimization method, thus the NumericalMathFunction has to provide its gradient:
  \begin{itemize}
  \item If the function is a meta-model generated by OpenTURNS, the analytical gradient is automatically provided.
  \item If it is an analytical function, OpenTURNS provides a gradient based on the centered finite difference method, that the user can change to better fit ots will by another GradientImplementation (e.g. constructed by another finite difference method).
  \item If the function is loaded thanks to a wrapper and if the wrapper provide an implementation of the gradient, OpenTURNS uses it. If there is no gradient provided, OpenTURNS provides a gradient based on centered finite difference method, but with a parameterization different from the case of analytical functions (assuming a lower precision for the function evaluation than in the analytical case).
  \end{itemize}
  Be aware of the potential pitfalls associated with the use of finite differences and check the value of the finite difference epsilon for each dimension if AbdoRackwitz algorithm fails to converge.

\item[Some methods:]  \rule{0pt}{1em}

  \begin{description}

  \item \textit{getSpecificParameters}
    \begin{description}
    \item[Usage:] \textit{getSpecificParameters()}
    \item[Arguments:] none
    \item[Value:]  a AbdoRackwitzSpecificParameters, list of the parameters specific to the AbdoRackwitz algorithm
    \end{description}
    \bigskip
  \end{description}

  This  \textit{getMethod}  is associated to a \textit{setMethod}.
\end{description}

% =============================================================
\newpage
% \index{Optimization!Minimization of the distance under an equality constraint!AbdoRackwitzSpecificParameters}
\index{AbdoRackwitzSpecificParameters}
\subsubsection{AbdoRackwitzSpecificParameters}


\begin{description}
\item[Usage:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{AbdoRackwitzSpecificParameters()}
  \item \textit{AbdoRackwitzSpecificParameters(Tau, Omega, Smooth)}
  \end{description}

\item[Arguments:]  \rule{0pt}{1em}
  \begin{description}
  \item \textit{Tau}:  a real positive value, the multiplicative decrease of the linear step. It  must be $<1$.
  \item \textit{Omega}:  a real strictly positive value, the Armijo factor. It  must be $<1$ and should be rather small.
  \item \textit{Smooth}:  a real value $>1$, the increasing rate of the penalisation coefficient for the line search. It  must be $>1$ and should be rather near 1.
  \end{description}

\item[Values:]  \rule{0pt}{1em}

  \begin{description}
  \item in the first usage, the default values are considered for each parameter: \textit{Tau = 0.5}, \textit{Omega = $10^{-4}$}, \textit{Smooth = 1.2}.
  \item  in the second usage, all the parameters are specified.
  \end{description}


\item[Some methods:]  \rule{0pt}{1em}

  \begin{description}

  \item \textit{getOmega}
    \begin{description}
    \item[Usage:] \textit{getOmega()}
    \item[Arguments:] none
    \item[Value:]  a real value between 0 and 1, the Armijo factor
    \end{description}
    \bigskip

  \item \textit{getSmooth}
    \begin{description}
    \item[Usage:] \textit{getSmooth()}
    \item[Arguments:] none
    \item[Value:]  a real value $> 1$, the increasing rate of the penalisation coefficient for the line search
    \end{description}
    \bigskip

  \item \textit{getTau}
    \begin{description}
    \item[Usage:] \textit{getTau()}
    \item[Arguments:] none
    \item[Value:]  a real value between 0 and 1, the multiplicative decrease of the linear step
    \end{description}
    \bigskip
  \end{description}

  This  \textit{getMethod}  is associated to a \textit{setMethod}.
\end{description}

% =============================================================
\newpage
% \index{Optimization!Minimization of the distance under an equality constraint!SQP}
\index{SQP}
\subsubsection{SQP}

This class inherits from the NearestPointAlgorithmImplementation class.
\begin{description}
\item[Usage:] \textit{SQP(specificParameters, levelFunction)}

\item[Arguments:]  \rule{0pt}{1em}
  \begin{description}
  \item \textit{specificParameters}: a SQPSpecificParameters, list of the parameters specific to the SQP algorithm
  \item \textit{levelFunction}: a NumericalMathFunction, the constraint function of the constrained optimization problem
  \end{description}
\item[Some methods:]  \rule{0pt}{1em}

  \begin{description}

  \item \textit{getSpecificParameters}
    \begin{description}
    \item[Usage:] \textit{getSpecificParameters()}
    \item[Arguments:] none
    \item[Value:]  a SQPSpecificParameters, list of the parameters specific to the SQP algorithm
    \end{description}
    \bigskip
  \end{description}

  This  \textit{getMethod}  is associated to a \textit{setMethod}.
\end{description}

% =============================================================
\newpage
% \index{Optimization!Minimization of the distance under an equality constraint!SQPSpecificParameters}
\index{SQPSpecificParameters}
\subsubsection{SQPSpecificParameters}


\begin{description}
\item[Usage:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{SQPSpecificParameters()}
  \item \textit{SQPSpecificParameters(Omega, Smooth, Tau)}
  \end{description}

\item[Arguments:]  \rule{0pt}{1em}
  \begin{description}
  \item \textit{Omega}:  a real value, the Armijo factor, must be > 0 and <1 but rather small.
  \item \textit{Smooth}:  a real value, the increasing rate of the penalisation coefficient for the line search, must be >1 but rather near 1.
  \item \textit{Tau}:  a real value, the multiplicative decrease of the linear step, with \textit{0 < Tau < 1}.

  \end{description}

\item[Values:]  \rule{0pt}{1em}

  \begin{description}
  \item in the first usage, the default values are considered for each parameter: \textit{Omega = $10^{-4}$}, \textit{Smooth = 1.2}, \textit{Tau = 0.5}.
  \item  in the second usage, all the parameters are specified.
  \end{description}


\item[Some methods:]  \rule{0pt}{1em}

  \begin{description}

  \item \textit{getOmega}
    \begin{description}
    \item[Usage:] \textit{getOmega()}
    \item[Arguments:] none
    \item[Value:]  a real value between 0 and 1, Armijo factor
    \end{description}
    \bigskip

  \item \textit{getSmooth}
    \begin{description}
    \item[Usage:] \textit{getSmooth()}
    \item[Arguments:] none
    \item[Value:]  a real value > 1, the increasing rate of the penalisation coefficient for the line search
    \end{description}
    \bigskip

  \item \textit{getTau}
    \begin{description}
    \item[Usage:] \textit{getTau()}
    \item[Arguments:] none
    \item[Value:]  a real value between 0 and 1, multiplicative decrease of the linear step
    \end{description}
    \bigskip
  \end{description}

  These  \textit{getMethod}  are associated to  \textit{setMethod}.
\end{description}

% =============================================================
\newpage
% \index{Optimization!Minimization of the distance under an equality constraint!NearestPointAlgorithmImplementationResult}
\index{NearestPointAlgorithmImplementationResult}
\subsubsection{NearestPointAlgorithmImplementationResult}


\begin{description}
\item[Usage:] structure created by the method run() of a NearestPointAlgorithm and obtained thanks to the method \textit{getResult()}

\item[Some methods:]  \rule{0pt}{1em}

  \begin{description}

  \item \textit{drawErrorHistory}
    \begin{description}
    \item[Usage:] \textit{drawErrorHistory()}
    \item[Arguments:] none
    \item[Value:]  a Graph that draws the evolution of the absolute error, the relative error, the constraint error and the residual error as a function of the iteration number.
    \end{description}
    \bigskip

  \item \textit{getAbsoluteError}
    \begin{description}
    \item[Usage:] \textit{getAbsoluteError()}
    \item[Arguments:] none
    \item[Value:]  a NumericalScalar, the absolute error: the distance between the two last successive iterates defined by:
\begin{align}\label{absError}
\varepsilon_{abs} = ||\vect{u}_{n+1}-\vect{u}_n||
\end{align}

    \end{description}
    \bigskip

  \item \textit{getConstraintError}
    \begin{description}
    \item[Usage:] \textit{getConstraintError()}
    \item[Arguments:] none
    \item[Value:] a real value, the absolute value of the constraint function minus the level value at the last iterate point defined by:
\begin{align}\label{consError}
\varepsilon_{cons} = |f(\vect{u}_{n})|
\end{align}

    \end{description}
    \bigskip

  \item \textit{getIterationsNumber}
    \begin{description}
    \item[Usage:] \textit{getIterationsNumber()}
    \item[Arguments:] none
    \item[Value:]  an integer, the  number of performed iterations of the algorithm when the algorithm stops
    \end{description}
    \bigskip

  \item \textit{getMinimizer}
    \begin{description}
    \item[Usage:] \textit{getMinimizer()}
    \item[Arguments:] none
    \item[Value:]  a NumericalPoint, the last iterate when the algorithm stops (the solution of the optimization problem)
    \end{description}
    \bigskip

  \item \textit{getRelativeError}
    \begin{description}
    \item[Usage:] \textit{getRelativeError()}
    \item[Arguments:] none
    \item[Value:] a real value, the relative distance between the two last successive iterates (with regards the last iterate)defined by:
\begin{align}\label{relError}
\displaystyle \varepsilon_{rel} = \frac{||\vect{u}_{n+1}-\vect{u}_n||}{||\vect{u}_{n+1}||}
\end{align}
    \end{description}
    \bigskip

  \item \textit{getResidualError}
    \begin{description}
    \item[Usage:] \textit{getResidualError()}
    \item[Arguments:] none
    \item[Value:]   a real value, the orthogonality error of the solution point (lack of orthogonality between the vector Center - Last Iterate and the constraint surface) defined by:
\begin{align}\label{resError}
\displaystyle \varepsilon_{res} = |<\vect{u}_{n}, \nabla f(\vect{u}_{n})>|
\end{align}
    \end{description}
    \bigskip

  \item \textit{getInputSample}
    \begin{description}
    \item[Usage:] \textit{getInputSample()}
    \item[Arguments:] None.
    \item[Value:] a sample that contains the function inputs during the optimization
    \end{description}
    \bigskip

  \item \textit{getOutputSample}
    \begin{description}
    \item[Usage:] \textit{getOutputSample()}
    \item[Arguments:] None.
    \item[Value:] a sample that contains the function outputs during the optimization
    \end{description}

  \end{description}

\end{description}


% =============================================================

\newpage
% \index{Optimization!Optimization of a function under an inequality constraint}
\subsection{Optimization of a function under bound constraints}

% \index{Optimization!Optimization of a function under an inequality constraint!BoundConstrainedAlgorithm}
\index{BoundConstrainedAlgorithm}
\subsubsection{BoundConstrainedAlgorithm}

\begin{description}
\item[Usage:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{BoundConstrainedAlgorithm(objFct, boundCons, startingPt, BndConstAlgoImp.MINIMIZATION)}
  \item \textit{BoundConstrainedAlgorithm(objFct, boundCons, startingPt, BndConstAlgoImp.MAXIMIZATION)}
  \item \textit{BoundConstrainedAlgorithm(BndConstAlgoImp)}
  \end{description}

\item[Arguments:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{objFct}: a NumericalMathFunction, the function to minimize or maximize (objective function).
  \item \textit{startingPt}: a Interval, the intervall $[\vect{a}, \vect{b}] \in \overline{\Rset}^n$.
  \item \textit{startingPt}: a NumericalPoint, the initial point of the optimization algorithm.
  \item \textit{BndConstAlgoImp.MINIMIZATION}: the code which specifies that it is a minimization optimization. It is possible to write $O$ instead of it.
  \item \textit{BndConstAlgoImp.MAXIMIZATION}: the code which specifies that it is a maximization optimization. It is possible to write $1$ instead of it.
  \item \textit{boundConstrainAlgorithmImplementation}: a BoundConstrainAlgorithmImplementation, the implementation of the bound constrain algorithm, which is \textit{TNC}.
  \end{description}

\item[Value:] a BoundConstrainedAlgorithm, which resolves the optimization problems:
  \begin{align*}
    \min_{\vect{a} \leq \vect{u} \leq \vect{b} } f(\vect{u})
  \end{align*}
  or
  \begin{align*}
    \max_{\vect{a} \leq \vect{u} \leq \vect{b} } f(\vect{u})
  \end{align*}
  where $f$ is the objective function and $[\vect{a},\vect{b}] \in \overline{\Rset}^n$.
  \begin{description}
  \item In the first and second usages, the optimization algorithm is the TNC one with its default specific parameters.
  \item In the third usage, the optimization problem is entirely specified by the implementation of the bound constrain algorithm.
  \end{description}

\item[Some methods:]  \rule{0pt}{1em}

  \begin{description}

  \item \textit{getBoundConstraints}
    \begin{description}
    \item[Usage:] \textit{getBoundConstraints()}
    \item[Arguments:] none
    \item[Value:]  a Interval, the interval $[\vect{a},\vect{b}] \in \overline{\Rset}^n$ where the optimization is performed.
    \end{description}
    \bigskip

  \item \textit{getMaximumAbsoluteError}
    \begin{description}
    \item[Usage:] \textit{getMaximumAbsoluteError()}
    \item[Arguments:] none
    \item[Value:] a positive real value, precision goal for the value of x in the stopping criterion (after applying x scaling factors). If negative 0.0, that parameter is set to $\sqrt{machine-precision}$.
    \end{description}
    \bigskip

  \item \textit{getMaximumConstraintError}
    \begin{description}
    \item[Usage:] \textit{getMaximumConstraintError()}
    \item[Arguments:] none
    \item[Value:] a positive real value, the precision goal for the value of the projected gradient in the stopping criterion (after applying x scaling factors): if negative, that parameter is set to 1e-2 * sqrt(accuracy). Setting it to 0.0 is not recommended.
    \end{description}
    \bigskip

  \item \textit{getMaximumEvaluationsNumber}
    \begin{description}
    \item[Usage:] \textit{getMaximumEvaluationsNumber()}
    \item[Arguments:] none
    \item[Value:] an integer, the maximum number of evaluations of the objective function.
    \end{description}
    \bigskip

  \item \textit{getMaximumObjectiveError}
    \begin{description}
    \item[Usage:] \textit{getMaximumObjectiveError()}
    \item[Arguments:] none
    \item[Value:] a positive real value, the precision goal for the value of the objevive function in the stoping criterion. If negative, that parameter is set to accuracy.
    \end{description}
    \bigskip

  \item \textit{getObjectiveFunction}
    \begin{description}
    \item[Usage:] \textit{getObjectiveFunction()}
    \item[Arguments:] none
    \item[Value:] a NumericalMathFunction, the objective function.
    \end{description}
    \bigskip

  \item \textit{getResult}
    \begin{description}
    \item[Usage:] \textit{getResult()}
    \item[Arguments:] none
    \item[Value:] a BoundConstrainedAlgorithmImplementationResult, the structure containing all the results of the constrained optimization problem
    \end{description}
    \bigskip

  \item \textit{getStartingPoint}
    \begin{description}
    \item[Usage:] \textit{getStartingPoint()}
    \item[Arguments:] none
    \item[Value:] a NumericalPoint, the starting point of the constrained optimization research.
    \end{description}
    \bigskip

  \item \textit{run}
    \begin{description}
    \item[Usage:] \textit{run()}
    \item[Arguments:] none
    \item[Value:] none
    \item[Role:] it creates a BoundConstrainedAlgorithmImplementationResult, the optimization result which is accessible with the method getResult().
    \end{description}


  \end{description}


  These  \textit{getMethod}  are associated to  \textit{setMethod}.


\end{description}



% =============================================================


\newpage
% \index{Optimization!Optimization of a function under an inequality constraint!TNC (Truncated Newton Constrained)}
\index{TNC (Truncated Newton Constrained)}
\subsubsection{TNC (Truncated Newton Constrained)}

This class inherits from the BoundConstrainedAlgorithmImplementation class.\\

The TNC algorithm minimizes or maximizes an objective function $f$ with variables $x$ subjected to bounds $[\vect{a},\vect{b}] \in \overline{\Rset}^n$ , using gradient information.

\begin{description}
\item[Usage:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{TNC(specParam,  objFct, boundCons, startPt, TNC.MINIMIZATION)}
  \item \textit{TNC(specParam,  objFct, boundCons, startPt, TNC.MAXIMIZATION)}
  \end{description}

\item[Arguments:]  \rule{0pt}{1em}
  \begin{description}
  \item \textit{specParam}: a TNCSpecificParameters, the list of the parameters specific to the TNC algorithm
  \item \textit{objFct}: a NumericalMathFunction, the constraint function of the constrained  problem
  \item \textit{boundCons}: a Interval, the interval $[\vect{a},\vect{b}] \in \overline{\Rset}^n$ where the optimization is performed.
  \item \textit{startingPoint}: a NumericalPoint, the starting point of the constrained optimization research.
  \item \textit{TNC.MINIMIZATION, TNC.MAXIMIZATION}:  the code which specifies whether it is a minimization or a maximization optimization. It is possible to write $0$ instead of \textit{TNC.MINIMIZATION} and $1$ instead of \textit{TNC.MAXIMIZATION}.
  \end{description}

\item[Some methods:]  \rule{0pt}{1em}

  \begin{description}

  \item \textit{getSpecificParameters}
    \begin{description}
    \item[Usage:] \textit{getSpecificParameters()}
    \item[Arguments:] none
    \item[Value:]  a TNCSpecificParameters, the list of the parameters specific to the TNC algorithm
    \end{description}
  \end{description}

  This  \textit{getMethod}  is associated to a \textit{setMethod}.

\end{description}



% =============================================================


\newpage
% \index{Optimization!Optimization of a function under an inequality constraint!TNCSpecificParameters}
\index{TNCSpecificParameters}
\subsubsection{TNCSpecificParameters}

The TNC algorithm resolves: $\min_{\vect{x} \in [\vect{a},\vect{b}] \in \overline{\Rset}^n} f(\vect{x})$ and proceeds as follows under the proper regularity of the objective function $f$:
\begin{align*}
  \left\{
    \begin{array}{l}
      \vect{\nabla f}(\vect{x}) =\vect{0}  \\
      \mat{\nabla_2} f(\vect{x}) \mbox{ is definite positive}
    \end{array}
  \right.
\end{align*}

The Taylor development of second order of $f$ around  $\vect{x}_k$ leads to the determination of the iterate $\vect{x}_{k+1}$ such as:
\begin{equation}\label{linearSystem}
  \left\{
    \begin{array}{lcl}
      \vect{\Delta}_k & = & \vect{x}_{k+1} - \vect{x}_k  \\
      \mat{\nabla_2} f(\vect{x}_k)\vect{\Delta}_k & = & -\vect{\nabla f}(\vect{x}_k)
    \end{array}
  \right.
\end{equation}

The equation (\ref{linearSystem}) is truncated: the iterative research of $\vect{\Delta}_k$ is stopped as soon as $\vect{\Delta}_k$ verifies:
\begin{align*}
  || \mat{\nabla_2} f(\vect{x}_k)\vect{\Delta}_k + \vect{\nabla f}(\vect{x}_k) || \leq \eta ||\vect{\nabla f}(\vect{x}_k) ||
\end{align*}
At last, the iteration $k+1$ is defined by:
\begin{align*}
  \vect{x}_{k+1} = \vect{x}_k + \alpha_k \vect{\Delta}_k
\end{align*}
where $\alpha_k$ is the parameter \textit{stepmx}.



\begin{description}
\item[Usage:] \rule{0pt}{1em}
  \begin{description}
  \item \textit{TNCSpecificParameters()}
  \item \textit{TNCSpecificParameters(scale, offset, maxCGit, eta, stepmx, accuracy, fmin, rescale)}
  \end{description}

\item[Arguments:]  \rule{0pt}{1em}
  \begin{description}
  \item \textit{scale}:  a real value, the scaling factors to apply to each variable: if NULL, the factors are up-low for interval bounded variables and 1+|x] for the others.
  \item \textit{offset}: a real value, the constant to substract to each variable. If NULL, the constant are (up+low)/2 for interval bounded variables and x for the others.
  \item \textit{maxCGit}: an integer, the max. number of hessian*vector evaluation per main iteration. If maxCGit == 0, the direction chosen is -gradient. If maxCGit < 0, maxCGit is set to max(1,min(50,n/2)).
  \item \textit{eta}:  a positive real value, the severity of the line search. If < 0 or > 1, set to 0.25.
  \item \textit{stepmx}:   a real value, the maximum step for the line search. may be increased during call. If too small, will be set to 10.0.
  \item \textit{accuracy}:  a real value, the relative precision for finite difference calculations. If $\leq machine-precision$, set to $\sqrt{machine-precision}$.
  \item \textit{fmin}:   a real value, the minimum function value estimate
  \item \textit{rescale}: a real value, the objective function scaling factor (in log10) used to trigger the objective function value rescaling: if 0, rescale at each iteration; if a big value, never rescale; if < 0, rescale is set to 1.3.
  \end{description}


\item[Value:]  \rule{0pt}{1em}

  \begin{description}
  \item in the first usage, the default values are considered for each parameter: \textit{MaxCGit = 50}, \textit{Eta = 0.25}, \textit{Stepmx = 10.0}, \textit{Accuracy = 1.0e-4}, \textit{Fmin = 1.0}, \textit{Rescale = 1.3}.
  \item  in the second usage, all the parameters are specified.
  \end{description}





\item[Some methods:]  \rule{0pt}{1em}

  \begin{description}

  \item \textit{getAccuracy}
    \begin{description}
    \item[Usage:] \textit{getAccuracy()}
    \item[Arguments:] none
    \item[Value:]  a real value, the \textit{accuracy} parameter.
    \end{description}
    \bigskip
  \item \textit{getEta}
    \begin{description}
    \item[Usage:] \textit{getEta()}
    \item[Arguments:] none
    \item[Value:]  a positive real value, the \textit{eta} parameter.
    \end{description}
    \bigskip
  \item \textit{getFmin}
    \begin{description}
    \item[Usage:] \textit{getFmin()}
    \item[Arguments:] none
    \item[Value:]  a real value, the \textit{fmin} parameter.
    \end{description}
    \bigskip
  \item \textit{getMaxCGit}
    \begin{description}
    \item[Usage:] \textit{getMaxCGit()}
    \item[Arguments:] none
    \item[Value:]  an integer, the \textit{maxCGit} parameter.
    \end{description}
    \bigskip
  \item \textit{getOffset}
    \begin{description}
    \item[Usage:] \textit{getOffset()}
    \item[Arguments:] none
    \item[Value:]  a real value, the \textit{offset} parameter.
    \end{description}
    \bigskip
  \item \textit{getRescale}
    \begin{description}
    \item[Usage:] \textit{getRescale()}
    \item[Arguments:] none
    \item[Value:]  a real value, the \textit{rescale} parameter.
    \end{description}
    \bigskip
  \item \textit{getScale}
    \begin{description}
    \item[Usage:] \textit{getScale()}
    \item[Arguments:] none
    \item[Value:]  a real value, the \textit{scale} parameter.
    \end{description}
    \bigskip
  \item \textit{getStepmx}
    \begin{description}
    \item[Usage:] \textit{getStepmx()}
    \item[Arguments:] none
    \item[Value:]  a real value, the \textit{stepmx} parameter.
    \end{description}
  \end{description}

  These  \textit{getMethod}  are associated to  \textit{setMethod}.
\end{description}


% =============================================================

\newpage
% \index{Optimization!Optimization of a function under an inequality constraint!BoundConstrainedAlgorithmImplementationResult}
\index{BoundConstrainedAlgorithmImplementationResult}
\subsubsection{BoundConstrainedAlgorithmImplementationResult}



\begin{description}
\item[Usage:] structure created by the method run() of a BoundConstrainedAlgorithm and obtained thanks to the method \textit{getResult()}

\item[Some methods:]  \rule{0pt}{1em}

  \begin{description}

  \item \textit{getAbsoluteError}
    \begin{description}
    \item[Usage:] \textit{getAbsoluteError()}
    \item[Arguments:] none
    \item[Value:] a positive real value, precision obtained for the value of x in the stopping criterion (after applying x scaling factors). Care: if the algorithm is TNC, there is no information on that parameter: the Maximum absolute error is returned.
    \end{description}
    \bigskip

  \item \textit{getConstraintError}
    \begin{description}
    \item[Usage:] \textit{getConstraintError()}
    \item[Arguments:] none
    \item[Value:] a positive real value, the precision obtained for the value of the projected gradient in the stopping criterion (after applying x scaling factors).  Care: if the algorithm is TNC, there is no information on that parameter: the maximum constraint error is returned.
    \end{description}
    \bigskip

  \item \textit{getEvaluationsNumber}
    \begin{description}
    \item[Usage:] \textit{getEvaluationsNumber()}
    \item[Arguments:] none
    \item[Value:] an integer, the  number of evaluations of the objective function.
    \end{description}
    \bigskip

  \item \textit{getObjectiveError}
    \begin{description}
    \item[Usage:] \textit{getObjectiveError()}
    \item[Arguments:] none
    \item[Value:] a positive real value, the precision obtained for the value of the objevive function in the stoping criterion. Care: if the algorithm is TNC, there is no information on that parameter: the maximum objective error is returned.
    \end{description}
    \bigskip

  \item \textit{getOptimalValue}
    \begin{description}
    \item[Usage:] \textit{getOptimalValue()}
    \item[Arguments:] none
    \item[Value:] a real, the objective function value at the optimizer point.
    \end{description}
    \bigskip

  \item \textit{getOptimmizer}
    \begin{description}
    \item[Usage:] \textit{getOptimmizer()}
    \item[Arguments:] none
    \item[Value:] a NumericalPoint, solution of the constrained optimization problem.
    \end{description}


  \end{description}

\end{description}
